<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PHP - Değişkenler (Variables) </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META content=0 http-equiv=expires>
<link rel="stylesheet" type="text/css" href="main.css" media="screen" />
<script language="JavaScript" src="../js/browser.js"> </script>
<script type="text/javascript">
function myvoid()
{
}
</script>
</head>

<body onLoad="ayarla();">
<div id="taban">
    <table cellpadding="0" cellspacing="0" width="100%">
    <tr><td valign="top">
       <div id="soltaraf">
           <a href="../index.php"><img src="../img/aybim.png" border="0"></a><br /><br />
           <div class="menublock">
               <font color="#8e9ccb"><h3>Tanımlar</h3></font>
               <a href="javascript:myvoid();" class="nav">Başlarken</a>
               <a href="phptxt11.html" class="sub">ilk Anlatım</a>
               <a href="javascript:myvoid();" class="nav">Kurulumlar</a>
               <a href="phptxt21.html" class="sub">Genel Kurulum</a><br />
               <a href="phptxt22.html" class="sub">UNIX Kurulumu</a><br />
               <a href="phptxt23.html" class="sub">OSX Kurulumu</a><br />
               <a href="phptxt24.html" class="sub">Wins Kurulumu</a>
               <a href="javascript:myvoid();" class="nav">Dil Kuralları</a>
               <a href="phptxt31.html" class="sub">Temel yazım</a><br />
               <a href="phptxt32.html" class="sub">Tipler</a><br />
               <a href="phptxt33.html" class="sub">Değişkenler</a><br />
               <a href="phptxt34.html" class="sub">Değişmezler</a><br />
               <a href="phptxt35.html" class="sub">Deyimler</a><br />
               <a href="phptxt36.html" class="sub">İşlemler</a><br />
               <a href="phptxt37.html" class="sub">Kontrol Yapıları</a><br />
               <a href="phptxt38.html" class="sub">İşlevler</a><br />
               <a href="phptxt39.html" class="sub">Sınıflar Nesneler</a><br />
               <a href="phptxt391.html" class="sub">Ad uzayı</a><br />
               <a href="phptxt392.html" class="sub">İstisnalar</a>
               <a href="javascript:myvoid();" class="nav">Güvenlik</a>
               <a href="phptxt41.html" class="sub">Giriş</a><br />
               <a href="phptxt42.html" class="sub">Genel bilgi</a><br />
               <a href="phptxt43.html" class="sub">CGI iklisi</a><br />
               <a href="phptxt44.html" class="sub">Apache modülü</a><br />
               <a href="phptxt45.html" class="sub">Dosyadüzeni</a><br />
               <a href="phptxt46.html" class="sub">Veritabanı</a><br />
               <a href="phptxt47.html" class="sub">Hatalar</a><br />
               <a href="phptxt48.html" class="sub">Diğerleri</a><br />
               <a href="javascript:myvoid();" class="nav">Özellikler</a>
               <a href="phptxt51.html" class="sub">HTTP Şifresi</a><br />
               <a href="phptxt52.html" class="sub">Çerezler</a><br />
               <a href="phptxt53.html" class="sub">Oturumlar</a><br />
               <a href="phptxt54.html" class="sub">XForm</a><br />
               <a href="phptxt55.html" class="sub">DosyaYükleme</a><br />
               <a href="phptxt56.html" class="sub">UzakDosyalar</a><br />
               <a href="phptxt57.html" class="sub">Bağlantılar</a><br />
               <a href="phptxt58.html" class="sub">VTBağlantısı</a>
               <font color="#8e9ccb"><h3>Gelişmiş</h3></font>
               <a href="phptxt7.html" class="nav">Php Kökü</a>
               <a href="phptxt8.html" class="nav">Ekler</a>
           </div>
       </div>
    </td><td valign="top">
       <center><h2>PHP Hyperlink Preprocessor</h2></center>
       <div id="ortataraf">
<!-- cascading style sheets ardaşık stil sayfaları -->
         <span><img src="img/notebook1.gif"></span>
         <div id="canvas">
<div id="sag"><span class="yazi">15 Ocak 2008</span></div>
<h2>Değişkenler (Variables)</h2>
<div id="bdy" class="yazi">

<h3>Temel</h3>

PHP değişkenleri başında dolar işareti olan değişken adından oluşur. Değişken adları büyük küçük harf duyarlıdır.
<br /><br />
Değişken adları PHP içindeki diğer etiketlerle aynı kuralları izler. Geçerli değişken adı harf ya da altçizgiyle başlar. Kurallı deyimlerle tanımlamak gerekirse aşağıdaki biçimde gösterilir:
<pre>
'[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
</pre>
    Not: Burada bir harf a-z, A-Z ve 127 ile 255 arasındaki ASCII karakterlerdir.
<br /><br />
    Not: $this özel değişkendir ve ona atama yapılamaz.

<pre>
&lt;?php
$var = 'Bob';
$Var = 'Joe';
echo "$var, $Var";      // çıktılar "Bob, Joe"

$4site = 'not yet';     // geçersiz; rakamla başlar
$_4site = 'not yet';    // geçerli; alt çizgiyle başlar
$täyte = 'mansikka';    // geçerli; 'ä' (Uzatılmış) ASCII 228.
?&gt;
</pre>

PHP 3 altında tüm değişkenlere bir değer atanması gerekirdi. Bugün ise, bir değişkene bir deyim atayınca, deyim değişkene kopyalanır. Bunun anlamı, bir değişkeni diğerine atayınca, birinin değerini değiştirmek diğerini etkilemez.
<br /><br />
PHP 4 zamanından beri PHP değişkenlere değer atamasında başka bir yol daha gösterir: Adresle atama. Buna göre değişken, yeni değeri gösterir (yeni değerin adresini içerir).
<br /><br />
Adres atamasında, kaynak değişkenin başına (& işareti) eklenir.
<pre>
&lt;?php
$foo = 'Bob';              // $foo değişkenine 'Bob' değeri atanır
$bar = &$foo;              // $bar $foo için adres gösterir
$bar = "My name is $bar";  // $bar değiştirildi...
echo $bar;
echo $foo;                 // Şimdi de $foo değiştirildi
?&gt;
</pre>

Bilinmesi gereken bir konu da yalnız adlandırılmış değişkenler için adres ataması yapılabildiğidir.
<pre>
&lt;?php
$foo = 25;
$bar = &$foo;      // Bu doğru bir atamadır
$bar = &(24 * 7);  // geçersiz; adlandırılmamış bir deyim
                   // adres atamasında kullanılmış

function test()
{
   return 25;
}

$bar = &test();    // Geçersiz.
?&gt;
</pre>

PHP içinde değişkenlere ilk değer vermeye gerek yoktur ama, ilk değer vermek çok iyi bir alışkanlıktır. İlk değer almayan değişkenlerin varsayılan değeri FALSE, sıfır, boş yazı dizisi ya da boş dizidir.
<br /><br />
Örnek: İlklenmeyen değişkenlerin varsayılan değerleri
<pre>
&lt;?php
echo ($unset_bool ? "true" : "false"); // sonuç false
$unset_int += 25; // 0 + 25 =&gt; 25
echo $unset_string . "abc"; // "" . "abc" =&gt; "abc"
$unset_array[3] = "def"; // array() + array(3 =&gt; "def") =&gt; array(3 =&gt; "def")
?&gt;
</pre>

İlklenmemiş bir değişkenin varsayılan ilk değerini kullanmak bir dosya içine başka dosyayı eklemek (include, require) söz konusu olduğunda beklenmedik sorunlara neden olabilir. Daha sonra eklenen dosyada aynı değişken başka bir değerle kullanılıyor olabilir. Bir değişkenin daha önce kullanılıp kullanılmadığını öğrenmek için isset() işlemiyle kontrol yapılabilir.
<hr>

<h3>Önceden tanımlanmış değişkenler (Predefined variables)</h3>

PHP her kodlamada kullanılabilecek önceden tanımlı değişkenler sunar. Bunların hepsi aynı anda kullanılmayabilir. Bazıları sunucu türüne bağlıdır. Bazı değişkenler komut satırından çalıştırılan PHP ile kullanılmaz.
<h3>UYARI</h3>

PHP 4.2.0 sürümünden sonra "registery_globals" adlı yönlendirici "off" (kapalı) konumundadır. Evrensel değişkenleri kapalı olması önceden tanımlanmış değişkenlerin sayısını da etkiler. Örneğin $DOCUMENT_ROOT değeri yerine $_SERVER['DOCUMENT_DOOT']  kullanmak gerekir. Aynı biçimde $_GET['id']  http://www.example.com/test.php?id=3 URL adresindeki $id yerine kullanılır. Ya da $HOME yerine $_ENV['HOME'] kullanılır.
<br /><br />
Önceden tanımlanmış PHP değişkenlerinden var olanlar, süper evrensel değişken dizilerindeki gibi kullanılmalıdır.
<br /><br />
PHP 4.1.0 sürümünden sonra PHP önceden tanımlanmış dizilerden bazılarını yeni kullanıma sunar (web sunucusunda kullanılabilirse). Bunlar çevresel ve kullanıcı giriş alanı bilgileridir. Bu yeni değişkenler otomatik olarak evrensel olmalarıyla özeldir. Bu nedenle onlara süper evrensel adı verilir (PHP içinde kullanıcıların tanımladığı süper evrenseller yoktur). Unutmayın ki eski $HTTP_*_VARS türü değişkenler hala kullanılabilir durumdadır. 
<br /><br />
    Not: Değişken değişkenleri, "Superglobals" işlevi ya da sınıf yönteminin içinde değişken değişkeni olarak kullanılamaz.
<br /><br />
    Not: "Superglobals" ve HTTP_*_VARS aynı anda var olsalar da, aynı şey değildirler. Yani birini değiştirmek diğerini etkilemez.
<br /><br />
Eğer bazı değişkenler "variables_order" içindeki bazı değişkenlerle ilklenmemişse, onların önceden tanımlanmış PHP dizileri de boş kalır.

<h3>PHP Süer evrenselleri (Superglobals)</h3>
<dl>
<dt>$GLOBALS
    <dd>Kodlamanın evrensel uzayındaki tüm değişkenleri içerir. Bu dizinin anahtarı değişkenin adıdır.
    </dd></dt>
<dt>$_SERVER
    <dd>O anki kodlamanın çalışmasındaki çevre değişkenleri ya da web sunucunun ilkediği değişkenlerden oluşur. Eski $HTTP_SERVER_VARS dizisini anımsatır (eski dizi hala kullanılabilir)
    </dd></dt>
<dt>$_GET
    <dd>URL sorgulama yazı dizisiyle sağlanan değişkenlerdir. Eski $HTTP_GET_VARS dizisine benzer (eski dizi hala kullanılabilir)
    </dd></dt>
<dt>$_POST
    <dd>HTTP POST (göndermesi) işlemiyle sağlanan değişkenlerdir. Eski $HTTP_POST_VARS dizisine benzer (eski dizi hala kullanılabilir)
    </dd></dt>
<dt>$_COOKIE
    <dd>HTTP çerezleriyle kodlamaya sunulan değişkenleri belirtir. eski $HTTP_COOKIE_VARS dizisine benzer (hala kullanılabilir)
    </dd></dt>
<dt>$_FILES
    <dd>HTTP dosya göndermesiyle sağlanan değişkenleri belirtir. Eski $HTTP_POST_FILES dizisine benzer (hala geçerlidir)
    </dd></dt>
<dt>$_ENV
    <dd>Çevre (environment) tarafından kodlamaya sağlanan değişkenleri belirtir. Eski $HTTP_ENV_VARS dizisi gibidir (eskisi hala kullanılır).
    </dd></dt>
<dt>$_REQUEST
    <dd>Kodlamaya giriş değerleri GET, POST ve COOKIE giriş mekanizmalarıyla sağlanır. Bu nedenle güvenilir değildirler. Bu dizilerdeki değişkenlerin sırası ve varlığı PHP değişkenleri sıralama ayarları yönlendirilmesine bağlıdır. Bu dizinin eski sürümlerde karşılığı yoktur. request_variables() işlemine de bakın.
    <h3>Dikkat</h3>
PHP 4.3.0 sürümünden beri $_FILES $_REQUEST içinde bulunmaz.
<br /><br />
        Not: Komut satırından kullanıldığında bu değişkende argv ve argc öğeleri bulunmaz. Bu değerler $_SERVER dizisinde bulunur.
    </dd></dt>
<dt>$_SESSION
    <dd>Kodlamanın oturumunda kayıt edilen değişkenleri belirtir. Eskiden $HTTP_SESSION_VARS dizisi kullanılırdı (hala eskiler kullanılabilir)
    </dd></dt>
</dl>
<hr>

<h3>Değişkenin Kapsama Alanı (Variable scope)</h3>

PHP değişkenlerinin kapsama alanı tekdir ve belgenin tümünü içerir. Bu alan "required" ve "included" türü dosyaları da içerir.
<pre>
&lt;?php
$a = 1;
include 'b.inc';
?&gt;
</pre>
Bu örnekteki $a b.inc kodlamasında bile geçerlidir. Kullanıcıların tanımladığı işlevlerde yerel işlev kapsama alanı tanımlanabilir. İşlev içinde tanımlanan bir değişken o işlevin yerel kapsama alanı içinde kalır. Örnek:
<pre>
&lt;?php
$a = 1; /* evrensel kapsama alanı */ 

function Test()
{ 
    echo $a; /* yerel kapsama alanındaki bir değişkene erişir */ 
} 
Test();
?&gt;
</pre>

Bu kodlama bir çıktı vermez. Çünkü "echo" komutu yerel bir değişkene erişmek ister ve kapsama alanı içinde değişkenin bir değeri de yoktur. Bu nedenle hatalı sonuç verebilir. PHP evrensel değişkenleri işlev içinde kullanılacaksa evrensel olarak tanımlanmalıdırlar.
<h3>global (evrensel) anahtar (keyword)</h3>

Önce evrensel kullanımla ilgili bir örneğe bakalım:
<br /><br />
Evrensel Kullanım örneği
<pre>
&lt;?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?&gt;
</pre>
Yukarıdaki kodlamanın çıktısı 3 olur. İşlev içinde $a ve $b global olarak tanımlanınca, bu değişkenlerle ilgili işlemler evrensel tanımlar üzerinden yapılır. Bir işlev içinden sınırsız sayıda evrensel değişkenle işlem yapabilirsiniz.
<br /><br />
Evrensel boyuttan değikenleri kullanmanın bir başka yolu da $GLOBALS dizisiyle değişkenlere erişmektir. Yukarıdaki örnek şöyle yazılır:
<br /><br />
$GLOBALS kullanma örneği
<pre>
&lt;?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
} 

Sum();
echo $b;
?&gt;
</pre>
$GLOBALS dizisi evrensel değişkenlerin adlarıyla dizide anahtar olduğu bir yapıdır. Burada evrensel değişken $GLOBALS ile gösterilmiş olur (pointer kullanımı).
<br /><br />
Süper evrenseller ve kapsam örneği:
<pre>
&lt;?php
function test_global()
{
    // Önceden tanımlanan değişkenlerin çoğu "süper" evrensel değildir
    // ve 'global' ile tanımlanmaları işlevlerin içinde kullanılmaları
    // için gereklidir.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // "Superglobals" her kapsamda vardırlar ve
    // 'global' tanımı onlar için gerekmez. iPHP 4.1.0 sürümünden
    // beri kullanılırlar ve HTTP_POST_VARS artık kullanılmaz
    echo $_POST['name'];
}
?&gt;
</pre>
<h3>Sabit Değişkenleri Kullanma (static variables)</h3>
<br /><br />
Değişken kapsama alanıyla ilgili bir başka özellik sabir (static) değişkenlerdir. Sabir değişken yalnız işlevin yerel kapsamında vardır ama program işlevden çıksa da değerini kaybetmez. Aşağıdaki örneğe bakın:
<br /><br />
Sabit değikenleri gösteren örnek:
<pre>
&lt;?php
function Test()
{
    $a = 0;
    echo $a;
    $a++;
}
?&gt;
</pre>

Bu işlev çok anlamsızdır. Her çağrıldığında $a değerini sıfır yapar sonra "0" yazdırır ve $a değerini bir arttırır. İşlev bitince $ a değişkeninin değeri de yok olur. Kullanışlı bir sayaç işlevi yapmak için $a değişkeni sabit olarak tanımlanmalıdır:
<br /><br />
Sabir değişken kullanımı
<pre>
&lt;?php
function Test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?&gt;
</pre>

Şimdi Test() işlevi her çağrıldığında $a değeri yazdırılır ve bir arttırılır.
<br /><br />
Sabit değişkenler, özyinelemeli (recursive) işlevlerle uğraşmanın bir yoludur.
Özyinelemeli işlev yaparken dikkat edilmesi gereken konu, bitiş noktasının iyi ayarlanabilmesidir. Yoksa sonsuz özyinelemeyle karşı karşıya kalabilirsiniz. Aşağıdaki örnekte sayaç 10 sayısına kadar sayar ve sonra durur.
<br /><br />
Özyinelemeli işlevlerde sabit değişkenler
<pre>
&lt;?php
function Test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count &lt; 10) {
        Test();
    }
    $count--;
}
?&gt;
</pre>
<br /><br />
Sabit değişkenler yukarıdaki örnekte gösterildiği gibi kullanılabilir. Deyimlerin sonucunu bu değişkenlere atamak tarama hatası oluşturur.
<br /><br />
Sabit değişkenleri tanımlamak
<pre>
    &lt;?php
    function foo(){
        static $int = 0;          // doğru 
        static $int = 1+2;        // yanlış  (bu bir deyim)
        static $int = sqrt(121);  // yanlış  (bu da bir deyim)
        $int++;
        echo $int;
    }
    ?&gt;
</pre>

<h3>Evrensel ve Sabit değişkenlerle erişim </h3>

PHP 4 sürücüsü olan Zend Makinesi, değişkenler için erişim açısından sabit ve evrensel değiştiriciye uyarlar. Örneğin gerçek evrensel değişken bir işlev kapsama alanına 'global' deyimiyle taşındığında, deyim o evrensel değişken için adres yaratır Ama bu aşağıdaki örnekte olduğu gibi beklenmedik davranışlara neden olabilir:
<pre>
&lt;?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?&gt;
</pre>

Bu örneği çalıştırınca aşağıdaki çıktı elde edilir:
<pre>
NULL
object(stdClass)(0) {
}
</pre>

Benzeri davranış sabit deyimlere uygulanır. Göstergeler sabit saklanmaz:
<pre>
&lt;?php
function &get_instance_ref() {
    static $obj;

    echo 'Sabit nesne: ';
    var_dump($obj);
    if (!isset($obj)) {
        // sabit değişkene bir adres ata
        $obj = &new stdclass;
    }
    $obj-&gt;property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;
    echo 'Sabit nesne: ';
    var_dump($obj);
    if (!isset($obj)) {
        // sabit değişkene nesneyi ata
        $obj = new stdclass;
    }
    $obj-&gt;property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?&gt;
</pre>
Bu örnek çalıştırıldığında çıktı aşağıdaki gibi olur:
<pre>
Sabit nesne: NULL
Sabit nesne: NULL

Sabit nesne: NULL
Sabit nesne: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
</pre>   

Bu örnekte sabit değişkene bir adres atamanın nasıl yapıldığı gösterilir. &get_instance_ref() işlevi ikinci kez çağrıldığında anımsanmaz.

<hr>

<h3>Değişken değişkenler (Variable variables)</h3>

Bazen değişken değişken adları olması iyidir. Bunun anlamı bir değişken adı dinamik olarak kurulur ve kullanılır. Normal bir değişken aşağıdaki gibi bir komutla kurulur:
<pre>
&lt;?php
$a = 'hello';
?&gt;
</pre>

Ama bir değişken değişken bir değişken değerini alır ve onu bir başka değişkenin adı olarak kullanır. Yukarıdaki örnekte hello, iki dolar işaretiyle bir değişkenin adı olarak kullanılır.
<pre>
&lt;?php
$$a = 'world';
?&gt;
</pre>

PHP sembol ağacında iki değişken tanımlar ve saklar. Bunlardan biri $a içeriği "hello" ve $hello içeriği "world". O halde bu komut:
<pre>
&lt;?php
echo "$a ${$a}";
?&gt;
</pre>

aynı çıktıyı çıkarır:
<pre>
&lt;?php
echo "$a $hello";
?&gt;
</pre>

Yani her ikisi de aynı şeyi yazar: hello world.

Dizilerde değişken değişkenleri kullanmadan önce bir karmaşayı çözmeniz gerekir. Eğer $$a[1] yazdığınızda tarama yapılırken $a[1] mi değişken olacak yoksa $$a mı değişken olacaktır. Bu karmaşayı çözmenin yazım kuralı parantezler kullanmaktır. Yani: ${$a[1]} ilki için, ${$a}[1] ikincisi için gereken doğru yazım kuralıdır.
<h3>UYARI</h3>

Değişken değişkenler süper evrensel dizilerle kullanılamaz. Değişken "$this" özel olduğu için dinamik adreslemede kullanılamaz.

<hr>

<h3>PHP dışındaki değişkenler</h3>
<h3>HTML Forms (GET ve POST)</h3>

Bir form PHP kodlamasına gönderilince, o formdaki bilgi kodlamanın kullanımına otomatik olarak sunulur. Bu bilgiye erişim için pek çok yol vardır:
<br /><br />
Basit bir HTML form girişi
<pre>
&lt;form action="foo.php" method="post"&gt;
    Name:  &lt;input type="text" name="username" /&gt;&lt;br /&gt;
    Email: &lt;input type="text" name="email" /&gt;&lt;br /&gt;
    &lt;input type="submit" name="submit" value="Submit me!" /&gt;
&lt;/form&gt;
</pre>
Kuruluma ve kişisel tercihlere dayanarak HTML formlarını işlemek için sayısız yol vardır. Bazı örnekler:
<br /><br />
POST HTML form verilerine erişim
<pre>
&lt;?php 
// PHP 4.1.0 sürümünden beri var

   echo $_POST['username'];
   echo $_REQUEST['username'];

   import_request_variables('p', 'p_');
   echo $p_username;

// PHP 3 sürümlerinden beri  var.
// PHP 5 sürümünden beri bunlar ön tanımlılar.
// değişkenler register_long_array yönlendiricisiyle kapatılabilir.

   echo $HTTP_POST_VARS['username'];

// Eğer PHP yönlendiricisi register_globals = on olursa vardır.
// PHP 4.2.0 sürümünden beri register_globals = off varsayılan değerdir.
// Bu yönteme bel balamak pek akıllı olmaz.

   echo $username;
?&gt;
</pre>
GET form kullanmak da benzerdir ama burada doğru GET öntanımlı değişkenini kullanırsınız. GET aynı zamanda QUERY_STRING de çağrıştırır ('?' sonrasındaki bilgi içindir). Örneğin http://www.example.com/test.php?id=3 GET tütü veri içerir ve bu değere $_GET['id'] biçimiyle ve import_request_variables() ile erişilir.
<br /><br />
    Not: Süper evrensel değişkenler PHP 4.1.0 sürümünden sonra kullanıma açıldılar.
<br /><br />
Gösterildiği gibi PHP 4.2.0 öncesinde "register_globals" varsayılan değeri "on" idi. PHP bu değişkenlerin yönlendiricisinin "off" olduğunu ve kodlamanın böyle yapılması gerektiğini belirtir.
<br /><br />
    Not: magic_quotes_gpc ayarlama yönlendiricisi Get, Post ve Cookies değerlerini etkiler. Eğer 'on' yapılara açılırsa (Bu "PHP!") değeri hemen (Bu \"PHP!\") olur. Ters kesmeyle saklamak Veri Tabanına eklemek için gereklidir. addslashes() ve stripslashes() ve magic_quotes_sybase konularına da bakın.
<br /><br />
PHP, form değişkenleri içindeki dizileri de anlar. Sınıflandırılabilecek değişkenleri birleştirir, ya da bu özelliği çoklu seçimi olan girişlerde kullanabilir. Örneğin bir formu kendisine gönderelim ve gönderilince verileri yazdıralım: 
<br /><br />
Daha karmaşık form değişkenleri
<pre>
&lt;?php
if ($_POST) {
    echo '&lt;pre&gt;';
    echo htmlspecialchars(print_r($_POST, true));
    echo '&lt;/pre&gt;';
}
?&gt;
&lt;form action="" method="post"&gt;
    Name:  &lt;input type="text" name="personal[name]" /&gt;&lt;br /&gt;
    Email: &lt;input type="text" name="personal[email]" /&gt;&lt;br /&gt;
    Beer: &lt;br /&gt;
    &lt;select multiple name="beer[]"&gt;
        &lt;option value="warthog"&gt;Warthog</option>
        &lt;option value="guinness"&gt;Guinness</option>
        &lt;option value="stuttgarter"&gt;Stuttgarter Schwabenbräu&lt;/option&gt;
    &lt;/select&gt;&lt;br /&gt;
    &lt;input type="submit" value="submit me!" /&gt;
&lt;/form&gt;
</pre>
PHP 3 içinde, form dizisi değişkenleri kullanımı tek boyutlu diziyle sınırlıdır. PHP 4 içinde bu tür sınırlama yoktur.
<h3>Resim gönderme (IMAGE SUBMIT) değişken adları (variable names)</h3>

Bir form gönderirken, standart gönderme düğmesi yerine aşağıdaki biçimle resim kullanabilirsiniz:
<pre>
&lt;input type="image" src="image.gif" name="sub" /&gt;
</pre>
Kullanıcı resmin bir yerini tıklayınca, ilgili form sunucuya iki ek değişkenler gönderilir (sub_x ve sub_y). Bu değişkenler kullanıcının resim içinde nereyi tıkladığını gösterir. Tarayıcı tarafından gönderilen gerçek değişken adları alt çizgi yerine nokta ile tanımlanır ama PHP noktaları hemen alt çizgiye çevirir.
<h3>HTTP Çerezleri (Cookies)</h3>

PHP saydam olarak Netscape Açıklamalarındakine benzer HTTP çerezlerini destekler. Çerezler uzaktaki tarayıcıda bilgi saklamanın bir yoludur. Böylece dönen kullanıcıyı izler ya da yakalar. Çerezleri kurmak setcookie() işleviyle olur. Çerezler HTTP başlığının bir parçasıdır bu nedenle setcookie() tarayıcıya hiç bir çıktı gönderilmeden iletilmelidir. Bu header() işleviyle aynı sınırlamayı anlatır. Çerez verileri daha sonra uygu çerez verileri dizisinde bulunur ($_COOKIE, $HTTP_COOKIE_VARS ayrıca $_REQUEST bu iş için kullanılan değerlerdir)
<br /><br />
Bir çerez değişkenine birden çok değer atamak isterseniz, onu bir dizi olarak atamalısınız:
<pre>
&lt;?php
  setcookie("MyCookie[foo]", 'Deneme 1', time()+3600);
  setcookie("MyCookie[bar]", 'Deneme 2', time()+3600);
?&gt;
</pre>

Bu iki değişik çerez yaratır ama MyCookie kodlamanızda hala bir dizidir. Eğer bir çerezi birçok değerle kullanmak isterseniz, değer üzerinde önce serialize() ya da explode() kullanın.
<br /><br />
Unutmayın ki bir çerez aynı adlı önceki çerezi yol ve alan adı farklı değilse, değiştirir. O zaman alışveriş sepeti uygulamasında bir sayaç göndermek ve onu işlemler arasında arttırmak gerekebilir.
<br /><br />
setcookie() örneği:
<pre>
&lt;?php
if (isset($_COOKIE['count'])) {
    $count = $_COOKIE['count'] + 1;
} else {
    $count = 1;
}
setcookie('count', $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?&gt;
</pre>
<h3>Gelen değişken adlarındaki noktalar</h3>

PHP bir kodlamaya geçirilen değişkenlerin adlarını değiştirmez. Ama bilinmelidir ki nokta PHP değişkenleri için geçerli bir karakter değildir. Bu nedenle aşağıdakine bakın:
<pre>
&lt;?php
$varname.ext;  /* geçersiz değişken adı */
?&gt;
</pre>
Şimdi tarayıcının gördüğü peşinde dizi birleştirme işlemi olan ve peşinden çıplak yazı dizisi 'ext' olan $varname adlı değişkendir. Haklı olarak bu istenilen sonuç değildir.
<br /><br />
Bu nedenle, PHP gelen değişkendeki her noktayı alt çizgiye çevirir.
<h3>Değişken türlerini Algılama </h3>

PHP değişkenlerin türlerini algıladığından ve gerek olduğunda çevirdiğinden, bir anda değişken ne tür tanımlandığı çok açık değildir. PHP değişkenin türünü anlamak için birkaç işlev kullanır: gettype(), is_array(), is_float(), is_init(), is_object() ve is_string().
</div>
         </div>
         <span><img src="img/notebook1.gif"><br /></span>
       </div>
    </td><td valign="top">
       <div id="sagtaraf">
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x600, created 1/16/08
google_ad_slot = "7007060807";
google_ad_width = 120;
google_ad_height = 600;
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x240, created 1/25/08
google_ad_slot = "8433790203";
google_ad_width = 120;
google_ad_height = 240;
google_cpa_choice = ""; // on file
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
       </div>
    </td></tr>
    </table>
</div>
</body>
</html>
