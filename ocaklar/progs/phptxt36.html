<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PHP - İşlemler </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META content=0 http-equiv=expires>
<link rel="stylesheet" type="text/css" href="main.css" media="screen" />
<script language="JavaScript" src="../js/browser.js"> </script>
<script type="text/javascript">
function myvoid()
{
}
</script>
</head>

<body onLoad="ayarla();">
<div id="taban">
    <table cellpadding="0" cellspacing="0" width="100%">
    <tr><td valign="top">
       <div id="soltaraf">
           <a href="../index.php"><img src="../img/aybim.png" border="0"></a><br /><br />
           <div class="menublock">
               <font color="#8e9ccb"><h3>Tanımlar</h3></font>
               <a href="javascript:myvoid();" class="nav">Başlarken</a>
               <a href="phptxt11.html" class="sub">ilk Anlatım</a>
               <a href="javascript:myvoid();" class="nav">Kurulumlar</a>
               <a href="phptxt21.html" class="sub">Genel Kurulum</a><br />
               <a href="phptxt22.html" class="sub">UNIX Kurulumu</a><br />
               <a href="phptxt23.html" class="sub">OSX Kurulumu</a><br />
               <a href="phptxt24.html" class="sub">Wins Kurulumu</a>
               <a href="javascript:myvoid();" class="nav">Dil Kuralları</a>
               <a href="phptxt31.html" class="sub">Temel yazım</a><br />
               <a href="phptxt32.html" class="sub">Tipler</a><br />
               <a href="phptxt33.html" class="sub">Değişkenler</a><br />
               <a href="phptxt34.html" class="sub">Değişmezler</a><br />
               <a href="phptxt35.html" class="sub">Deyimler</a><br />
               <a href="phptxt36.html" class="sub">İşlemler</a><br />
               <a href="phptxt37.html" class="sub">Kontrol Yapıları</a><br />
               <a href="phptxt38.html" class="sub">İşlevler</a><br />
               <a href="phptxt39.html" class="sub">Sınıflar Nesneler</a><br />
               <a href="phptxt391.html" class="sub">Ad uzayı</a><br />
               <a href="phptxt392.html" class="sub">İstisnalar</a>
               <a href="javascript:myvoid();" class="nav">Güvenlik</a>
               <a href="phptxt41.html" class="sub">Giriş</a><br />
               <a href="phptxt42.html" class="sub">Genel bilgi</a><br />
               <a href="phptxt43.html" class="sub">CGI iklisi</a><br />
               <a href="phptxt44.html" class="sub">Apache modülü</a><br />
               <a href="phptxt45.html" class="sub">Dosyadüzeni</a><br />
               <a href="phptxt46.html" class="sub">Veritabanı</a><br />
               <a href="phptxt47.html" class="sub">Hatalar</a><br />
               <a href="phptxt48.html" class="sub">Diğerleri</a><br />
               <a href="javascript:myvoid();" class="nav">Özellikler</a>
               <a href="phptxt51.html" class="sub">HTTP Şifresi</a><br />
               <a href="phptxt52.html" class="sub">Çerezler</a><br />
               <a href="phptxt53.html" class="sub">Oturumlar</a><br />
               <a href="phptxt54.html" class="sub">XForm</a><br />
               <a href="phptxt55.html" class="sub">DosyaYükleme</a><br />
               <a href="phptxt56.html" class="sub">UzakDosyalar</a><br />
               <a href="phptxt57.html" class="sub">Bağlantılar</a><br />
               <a href="phptxt58.html" class="sub">VTBağlantısı</a>
               <font color="#8e9ccb"><h3>Gelişmiş</h3></font>
               <a href="phptxt7.html" class="nav">Php Kökü</a>
               <a href="phptxt8.html" class="nav">Ekler</a>
           </div>
       </div>
    </td><td valign="top">
       <center><h2>PHP Hyperlink Preprocessor</h2></center>
       <div id="ortataraf">
<!-- cascading style sheets ardaşık stil sayfaları -->
         <span><img src="img/notebook1.gif"></span>
         <div id="canvas">
<div id="sag"><span class="yazi">20 Ocak 2008</span></div>
<h2>İşlemler</h2>
<div id="bdy" class="yazi">
Bir işlem, bir ya da iki değerden yeni bir değer üreten şeye denir. Buna göre yapılandırmalar ve işlevler değer döndürdükleri için işlem olarak nitelendirilebilir. 
<br /><br />
Üç tür işlem vardır. Öncelikle tekli işlemler vardır. Bunlar tek değer üzerinde işlem yaparlar -- (örneğin eksiltme işlemi) ya da ++ (arttırma işlemi). İkinci sınıf, ikili işlemleri belirtir. PHP tarafından desteklenen işlemlerin çoğu bu gruba girer. Ve aşağıdaki liste işlemlerin önceliklerini gösterir.
<br /><br />
Üçüncü sınıf koşullu işlemdir (ternary operator). Bu işlem üçüncünün değerine göre iki deyimden birini seçmek için kullanılır. Koşullu işlemleri parantez içine almak güzel bir alışkanlık olur.
<h3>İşlem Öncelikleri</h3>

Bir işlemin önceliği, iki deyimi birbirine ne kadar sıkı bağladığına bağlıdır. Örneğin 1 + 5 * 3 deyiminde sonuç 16 olur, 18 değil. Çünkü çarpma daha önceliklidir. Parantezler öncelikleri değiştirmede kullanılır. Örneğin (1 + 5) * 3 sonucu 18 olur. Eğer işlemlerin öncelikleri eşitse, soldan sağa sırayla hesaplama yapılır.
<br /><br />
Aşağıdaki tablo işlemlerin önceliklerini listeler. En büyük öncelikli işleme tabloda daha önce yer verilmiştir. Daha az öncelikler altında sıralanırlar.
<h3>İşlem Öncelikleri Tablosu</h3>
<table class="yazi" border="1">
<tr><th> Yön Kuralı</th><th>İşlemler</th><th>Ek Bilgi</th></tr>
<tr><td>Yön-kuralsız</td><td>new</td><td>yeni</td></tr>
<tr><td>Sol</td><td>[ </td><td>array()</td></tr>
<tr><td>Yön-kuralsız</td><td>++ -- </td><td>arttırma/azaltma</td></tr>
<tr><td>Yön-kuralsız</td><td>~ - (int) (float) (string) (array) (object) @ </td><td>türler</td></tr>
<tr><td>Yön-kuralsız</td><td>instanceof </td><td>türler</td></tr>
<tr><td>Sağ </td><td>! </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>* / % </td><td>aritmetik</td></tr>
<tr><td>Sol </td><td>+ - . </td><td>aritmetik ve yazı dizisi</td></tr>
<tr><td>Sol </td><td>&lt;&lt; &gt;&gt; </td><td>bit işlemi</td></tr>
<tr><td>Yön-kuralsız</td><td>&lt; &lt;= &gt; &gt;= </td><td>karşılaştırma</td></tr>
<tr><td>Yön-kuralsız</td><td>== != === !== </td><td>karşılaştırma</td></tr>
<tr><td>Sol </td><td>& </td><td>bit işlemi ve göstergeler</td></tr>
<tr><td>Sol </td><td>^ </td><td>bit işlemi</td></tr>
<tr><td>Sol </td><td>| </td><td>bit işlemi</td></tr>
<tr><td>Sol </td><td>&& </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>|| </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>? : </td><td>Koşullu deyim</td></tr>
<tr><td>Sağ </td><td>= += -= *= /= .= %= &= |= ^= &lt;&lt;= &gt;&gt;= </td><td>atama</td></tr>
<tr><td>Sol </td><td>and </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>xor </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>or </td><td>mantıksal</td></tr>
<tr><td>Sol </td><td>, </td><td>çok kullanımlı</td></tr>
</table>
Sol yön kuralı deyimlerin soldan sağa hesaplandığını gösterir. Sağ yön kuralı tersi demektir.
<br /><br />
Yön Kuralı örneği
<pre>
&lt;?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -&gt; $a = 5, $b = 5
?&gt;
</pre>
Kodun okunurluğunu arttırmak için parantezler kullanın.
<br /><br />
    Not: Eişttir (= işareti) birçok işlemden daha az öncelikli olsa da, PHP aşağıdaki gibi deyimlere izin verir:
<pre>
if (!$a = foo())
</pre>
öyle ki foo() işlevinin sonucu, $a değişkenine atanır.
<hr>

<h3>Aritmetik İşlemler</h3>

Okuldaki temel aritmetik kurallarını hatırlarsanız bunlar da aynıdır.
<h3>Arithmetik İşlemler</h3>
<table class="yazi" border="1">
<tr><th>Örnek </th><th>Ad </th><th>Sonuç</th></tr>
<tr><td>-$a </td><td>Tersini alma </td><td>$a tersidir.</td></tr>
<tr><td>$a + $b </td><td>Toplama </td><td>$a ve $b toplamıdır.</td></tr>
<tr><td>$a - $b </td><td>Çıkartma </td><td>Di$a ve $b farkıdır.</td></tr>
<tr><td>$a * $b </td><td>Çarpma </td><td>$a ve $b çarpımıdır.</td></tr>
<tr><td>$a / $b </td><td>Bölme </td><td>$a ve $b bölümüdür.</td></tr>
<tr><td>$a % $b </td><td>Modülüs </td><td>$a bölü $b değerinin kalanıdır.</td></tr>
</table>
<br /><br />
Bölme işlemi: Eğer değişken değerleri tam sayı (ya da tam sayıya dönüştürülen yazı dizisi) değilse kayan noktalı sonuç üretir. Eğer sayılar tam bölünebiliyorsa sonuç tamsayı olur.
<br /><br />
Modülüs değişkenleri işlemden önce tamsayıya dönüşür (yalnız tamsayı bölümünü alarak).
<br /><br />
    Not: $a % $b işleminde eğer $a eksiyse kalan da eksi olur
<hr>

<h3>Atama İşlemi</h3>

Temel atama işlemi '=' işaretidir. Burada soldaki değiken sağdaki deyimin sonucunu değer olarak alır.
<br /><br />
Atama işleminin sonucu atanan değerdir. Yani "$a = 3" değeri 3 olur. Bu sizin hileli işler yapmanıza neden olur:
<pre>
&lt;?php

$a = ($b = 4) + 5; // $a 9 değerine eşittir ve $b değeri 4 olur.

?&gt;
</pre>
Temel atama işlemine ek olarak ikili aritmatikte, dizi birleştirmede ve yazi dizilerinde kullanılan "birleşik işlemler" vardır. Birleşik işlemler deyimdeki değeri hesaplamanızı sağlar ve bu değeri atamada kullanır.
<pre>
&lt;?php

$a = 3;
$a += 5; // $a değeri 8 olur, sanki: $a = $a + 5; denmiş gibi
$b = "Hello ";
$b .= "There!"; // $b değerini "Hello There!" yapar,
                // sanki $b = $b . "There!"; denmiş gibi

?&gt;
</pre>
Unutmayın ki atama işlemi bir değişkenin değerini diğerine kopyalar. Bu nedenle birinin değişmesi diğerini etkilemez. PHP yeni sürümlerinde adresle atamayı da desteklemektedir. Yani $var = &$othervar; yazım kuralında kopyalama yapılmaz ve her iki değişken de aynı veriyi gösterir. Eğer adresi taşıyan değişken değeri değişecek olursa diğer değişkenin verileri değişmez ama tersi olursa her iki değişken de aynı yeri gösterdiğinden yeni değeri kullanırlar.
<hr>

<h3>Bit (ikili-bitwise) İşlemleri</h3>

Buradaki işlemler bir tam sayıdaki belirtilen bit değerini "on" ya da "off" biçiminde değiştirilmesini sağlar. Eğer işlemin hem sol hem de sağ tarafında yazı dizisi varsa, bit işlemleri karakterlerin ASCII değerleri üzerinden çalışır.
<pre>
&lt;?php
echo 12 ^ 9; // Çıktı '5'

echo "12" ^ "9"; // Çiktı ters kesme karakteridir (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Çıktının ascii değerleri #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4
?&gt;
</pre>
<h3>Bit (ikili-bitwise) İşlemleri</h3>
<table class="yazi" border="1">
<tr><th>Örnek </th><th>Ad </th><th>Sonuç</th></tr>
<tr><td>$a & $b </td><td>Ve (And) </td><td>Hem $a hem de $b içindeki bir olan bitler bir olur.</td></tr>
<tr><td>$a | $b </td><td>Veya (Or) </td><td>$a ya da $b içindeki bitlerde biri bir ise sonuç bir olur.</td></tr>
<tr><td>$a ^ $b </td><td>Hariç Tutan Veyay (Xor) </td><td>$a ya da $b içinde bir olan bitler bir olur ama her ikisinin bir olması hariç tutulur.</td></tr>
<tr><td>~ $a </td><td>Hayır (Not) </td><td>$a içinde bir olanlar bir olmaz (Tersini alma).</td></tr>
<tr><td>$a &lt;&lt; $b </td><td>Sola Kaydır (Shift left) </td><td>$a bitlerini $b kez sola kaydırma (her adım 2 ile çarpmak demek)</td></tr>
<tr><td>$a &gt;&gt; $b </td><td>Sağa Kaydır (Shift right) </td><td>$a bitlerini $b kez sağa kaydırma (her adımda sayı ikiye bölünür)</td></tr>
</table>
<h3>Warning</h3>

32 bitlik sistemlerde sağa kaydırmayı 32 haneden fazla yapmayın. Aynı biçimde sola kaydırırken sayının 32 bitlik sayıdan büyük olmasına neden olmayın.
<hr>

<h3>Karşılaştırma İşlemi</h3>

Karşılaştırma işlemi iki değeri karşılaştırmanızı sağlar. Türlere göre karşılaştırma tablosu, karşılaştırma örneklerini göstermesi açısından önemlidir.
<h3>Karşılaştırma İşlemi</h3>
<table class="yazi" border="1">
<tr><th>Örnek </th><th>Ad </th><th>Sonuç</th></tr>
<tr><td>$a == $b </td><td>Eşit (Equal) </td><td>$a eşittir $b ise TRUE döner.</td></tr>
<tr><td>$a === $b </td><td>Özdeş (Identical) </td><td>$a eşittir $b ise ve aynı türdense TRUE döner. (PHP 4 sunuldu)</td></tr>
<tr><td>$a != $b </td><td>Eşit Değil (Not equal) </td><td>$a $b eşit değilse TRUE döner.</td></tr>
<tr><td>$a &lt;&gt; $b </td><td>Eşit Değil (Not equal) </td><td>$a eşit değildir $b ise TRUE döner.</td></tr>
<tr><td>$a !== $b </td><td>Özdeş Değil (Not identical) </td><td>$a eşit değildir $b ise ya da türleri aynı değilse TRUE döner. (PHP 4 sunuldu)</td></tr>
<tr><td>$a &lt; $b </td><td>Küçüktür (Less than) </td><td>$a $b den küçükse TRUE döner.</td></tr>
<tr><td>$a &gt; $b </td><td>Büyüktür (Greater than) </td><td>$a $b den büyükse TRUE döner.</td></tr>
<tr><td>$a <= $b &lt;/td><td>Küçük ya da eşittir (Less than or equal to) </td><td>$a $b den küçük ya da eşitse TRU döner.</td></tr>
<tr><td>$a &gt;= $b </td><td>Büyüktür ya da eşittir (Greater than or equal to) </td><td>Eğer $a $b den büyük ya da eşitse TRUE döner.</td></tr>
</table>
<br /><br />
Eğer bir tamsayıyı yazı dizisiyle karşılaştırırsanız, yazı dizisi sayıya çevrilir. Eğer iki sayısal diziyi karşılaştırırsanız, tamsayı olarak karşılaştırılırlar.
<pre>
&lt;?php
var_dump(0 == "a"); // 0 == 0 -&gt; true
var_dump("1" == "01"); // 1 == 1 -&gt; true
var_dump("1" == "1e0"); // 1 == 1 -&gt; true

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    // buraya hiç erişilmez,
    // çünkü "a" daha önce sıfırla karşılaştırılmıştı
    echo "a";
    break;
}
?&gt;
</pre>
Değişik türler için karşılaştırma aşağıdaki tabloya göre yapılır:
<h3>Değişik türlerle karşılaştırma</h3>
<table class="yazi" border="1">
<tr><th>İşlenen 1 Türü</th><th>İşlenen 2 Türü</th><th>Sonuç</th></tr>
<tr><td>null ya da yazı dizisi (string)</td><td>yazı dizisi (string) </td><td>NULL değerini "" yap, sayısal ya da sözcük karşılaştırması</td></tr>
<tr><td>mantıksal (bool) ya da null </td><td>herhangi biri (anything)</td><td>iMantıksala çevir, FALSE < TRUE</td></tr>
<tr><td>nesne (object)</td><td>nesne (object)</td><td>Hazır sınıflar kendi karşılaştırmalarını tanımlar, değişik sınıflar karşılaştırılamaz, PHP 4 içinde anyı sınıflar diziler gibi karşılaştırılırlar. PHP 5 için ayrı açıklama vardır.</td></tr>
<tr><td>yazı dizisi (string), kaynak (resource) ya da sayı (number)</td><td>yazi dizisi (string), kaynak (resource) ya da sayı (number) </td><td>Yazı dizilerini ve kaynakları sayılara çevirir (normal matemetik)</td></tr>
<tr><td>dizi (array)</td><td>dizi (array)</td><td>Daha az öğesi olan dizi daha küçüktür. Eğer işlenen 1 anahtarı işlenen 2 de bulunmazsa, o zaman diziler karşılaştırılamaz. Yoksa değer değer karşılaştırılır (aşağıdaki örneğe bakın)</td></tr>
<tr><td>dizi (array) </td><td>herhangi biri (anything)</td><td>dizi her zaman büyüktür</td></tr>
<tr><td>nesne (object)</td><td>herhangi biri (anything)</td><td>nesne her zaman büyüktür</td></tr>
</table>
<br />
Standart dizi (array) karşılaştırması örneği:
<pre>
&lt;?php
// Standart işlemlerle diziler böyle karşılaştırılır
function standard_array_compare($op1, $op2)
{
    if (count($op1) &lt; count($op2)) {
        return -1; // $op1 &lt; $op2
    } elseif (count($op1) &gt; count($op2)) {
        return 1; // $op1 &gt; $op2
    }
    foreach ($op1 as $key =&gt; $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // karşılaştırılamaz
        } elseif ($val &lt; $op2[$key]) {
            return -1;
        } elseif ($val &gt; $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?&gt;
</pre>
strcasecmp(), strcmp(), dizi işlemleri ve türler üzerine yazılan aöıklamaya bakın
<h3>Koşullu Atama İşlemi (Ternary Operator)</h3>

Karşılaştırma işlemlerinde biri "?:" (ya da koşullu atama) işlemidir.
<br /><br />
Varsayılan değer atama örneği:
<pre>
&lt;?php
// Örnek koşullu atama kullanımı hakkında
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// TYukarıdaki kodlama aşağıdaki if-else komutuyla eşdeğerdir
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?&gt;
</pre>
<code>(expr1) ? (expr2) : (expr3)</code> deyiminde;
Eğer expr1 TRUE sonuç verirse expr2 hesaplanır, eğer expr1 FALSE değer verirse expr1 hesaplanır.
<br /><br />
    Not: Unutmayın ki koşullu atama işlemi bir komuttur ve bir değişkene sonuçlanmaz ama komutun sonucunu oluşturur.
<br /><br />
    Not: koşullu atamaları stoklamamanız önerilir. İç içe tanımlanmış koşullu atamalarda PHP davranışı çok açık değildir.
<br /><br />
Belli olmayan koşullu atama davranışı örneği:
<pre>
    &lt;?php
    // ilk anda, aşağıdaki 'true' çıktısı verir
    echo (true?'true':false?'t':'f');

    // Halbuki yukarıdaki çıktı 't' değeridir.
    // Çünkü koşullu atama solda sağa hesaplanır

    // Yukarıdaki kodlamanın daha açık biçimi şöyledir:
    echo ((true ? 'true' : 'false') ? 't' : 'f');

    // Burada, ilk deyim için 'true' değeri hesaplanır
    // ve mantıksal doğru hesaplanır, ikinci koşullu
    // atama deyiminin 'true' bacağı çalıştırılır
    ?&gt;
</pre>
<hr>

<h3>Hata Kontrol işlemleri (Error Control Operators)</h3>

PHP bir hata kontrol işlemi destekler: @ işareti. PHP içinde bir deyimle bağdaştırıldığında bu deyimin üretebileceği herhangi bir hata mesajı dikkate alınmaz (atlanır).
<br /><br />
Eğer 'track_errors' özelliği açıldıysa, deyimin üreteceği herhangi bir hata mesajı '$php_errormsg' değişkeni içinde olur. Bu değişkenin her hatada içindeki değer değişir. Dolayısıyla kullanmadan önce içeriğine bakmayı unutmayın.
<pre>
&lt;?php
/* Kasıtlı Dosya hatası */
$my_file = @file ('non_existent_file') ya da
    die ("Dosyayı açma hatası: hata şöyledir '$php_errormsg'");

// Yalnız işlevler için değil herhangi bir deyim için de çalışır 
$value = @$cache[$key]; 
// Eğer dizin $key yoksa bir uyarı üretmez

?&gt;
</pre>
    Not: @-işlemi yalnız deyimlerde çalışır. Parmak basılacak basit kural şöyledir: Birşeyin değerini alabilirseniz, @ işlemini ona takabilirsiniz. Örneğin onu değişkenlere, işlevlere ve include() çağırma işlevine, değişmezlere ve benzerlerine takabilirsiniz.
<br /><br />
'error_reporting()' ve Hata çözümleri ve Kaydetme konulu açıklamayı da inceleyin
<h3>UYARI</h3>

Şu anda "@" hata-kontrol işlem öneki kritik hataları için hata raporlamasını bile durdurur. Diğer şeylerin dışında bir işlevden hataları bastırmak için (olmadığı için ya da yazım hatasından) "@" kullanırsanız, kodlama hemen ölür (die).
<hr>
<h3>ÇALIŞTIRMA İşlemleri</h3>

PHP bir çalıştırma (execution) işlemi destekler : terstırnak (``). Bunlar tek tırnak değildir. PHP tek tırnak içindekileri kabuk programıymış gibi çalıştırmaya çalışır. Dönen çıktı bir değişkene atanabilir. Ters tırnak kullanımı 'shell_exec()' ile aynıdır.
<pre>
&lt;?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?&gt;
</pre>
    Not: Ters tek tırnak işlemi "güvenli konumda" kapalıdır ya da 'shell_exec()' kapalı olduğunda çalışmaz.
<hr>

<h3>Arttırma/Eksiltme İşlemleri (Incrementing/Decrementing Operators)</h3>

PHP C dili türünden önce ve sonra arttırma ve eksiltme işlemlerini destekler.
<br /><br />
    Not: arttırma/eksiltme işlemleri mantıksal değerleri etkilemez. NULL değerini eksiltmenin bir anlamı yoktur, ama ama onları arttırmanın sonucu 1 olur.

<h3>Arttırma/Eksiltme İşlemleri</h3>
<table class="yazi" border="1">
<tr><th>Örnak </th><th>Ad </th><th>Etki</th></tr>
<tr><td>++$a </td><td>Ön-arttırma </td><td>$a bir arttırılır ve $a döner.</td></tr>
<tr><td>$a++ </td><td>Sonra-arttırma </td><td>$a döner sonra $a değeri bir arttırılır.</td></tr>
<tr><td>--$a </td><td>Ön-eksiltme </td><td>$a bir eksiltilir sonra $a değeri döner.</td></tr>
<tr><td>$a-- </td><td>Sonra-eksiltme </td><td>$a değeri döner, sonra $a bir eksiltilir.</td></tr>
</table>
Basit bir örnek kodlama:
<pre>
&lt;?php
echo "<h3>Sonradan Arttırma (Postincrement)</h3>";
$a = 5;
echo "5 olmalı: " . $a++ . "<br />\n";
echo "6 olmalı: " . $a . "<br />\n";

echo "<h3>Önceden Arttırma (Preincrement)</h3>";
$a = 5;
echo "6 olmalı: " . ++$a . "<br />\n";
echo "6 olmalı: " . $a . "<br />\n";

echo "<h3>Sonradan Eksiltme (Postdecrement)</h3>";
$a = 5;
echo "5 olmalı: " . $a-- . "<br />\n";
echo "4 olmalı: " . $a . "<br />\n";

echo "<h3>Önceden Eksiltme (Predecrement)</h3>";
$a = 5;
echo "4 olmalı: " . --$a . "<br />\n";
echo "4 olmalı: " . $a . "<br />\n";
?&gt;
</pre>
PHP karakter değişkenleriyle aritmetik işlem yapılırken Perl kavramlarını kullanır. Örneği Perl içinde 'Z' + 1 'AA' döndürür. Unutulmamalıdır ki karakter değişkenler arttırılamaz ve eksiltilemez ve yalnız ASCII karakterler (a-z ve A-Z desteklenir).
<br /><br />
Karakter değişkenler üzerinde aritmetik işlemler
<pre>
&lt;?php
$i = 'W';
for ($n=0; $n&lt;6; $n++) {
    echo ++$i . "\n";
}
?&gt;
</pre>
Yukarıdaki örneğin çıktırı şöyledir:
<pre>
X
Y
Z
AA
AB
AC
</pre>

mantıksal değerleri arttırmanın ya da eksiltmenin bir etkisi yoktur.
<hr>

<h3>Mantıksal İşlemler</h3>
<h3>Mantıksal İşlemler Tablosu</h3>
<table class="yazi" border="1">
<tr><th>Örnek </th><th>Ad </th><th>Sonuç</th></tr>
<tr><td>$a and $b </td><td>Ve </td><td>Hem $a hem de $b TRUE ise TRUE olur.</td></tr>
<tr><td>$a or $b </td><td>Veya </td><td>$a TRUE ya da $b TRUE ise TRUE olur.</td></tr>
<tr><td>$a xor $b </td><td>Eşitler Hariç </td><td>Ya $a TRUE ya da $b TRUE ise TRUE olur. İkiside TRUE ise hariç.</td></tr>
<tr><td>! $a </td><td>Hayır </td><td>$a doğry değilse TRUE olur.</td></tr>
<tr><td>$a && $b </td><td>Ve </td><td>$a ve $b her ikisi de doğru ise TRUE olur.</td></tr>
<tr><td>$a || $b </td><td>Veya </td><td>$a ya da $b den biri TRUE ise TRUE olur.</td></tr>
</table>
İki değişik işlem grubu olmasının nedeni önceliklerinin farklı olmasıdır. Ayrıca && ve || koşullarda kullanılır.
<br /><br />
Mantıksal işlemleri gösteren örnek:
<pre>
&lt;?php

// foo() hiç çağrılmaz çünkü bu işlemler kısa devredir.
$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// "||" or işlemine göre daha önceliklidir.
$e = false || true; // $e (false || true) sonucuna atanır ki true olur.
$f = false or true; // $f false değerine atanır
var_dump($e, $f);

// "&&" "and" işleminden daha önceliklidir
$g = true && false; // $g (true && false) sonucuna atanır ki false olur
$h = true and false; // $h false değerine atanır
var_dump($g, $h);
?&gt;
</pre>
Yukarıdaki örnek şöyle bir çıktı verir:
<pre>
bool(true)
bool(false)
bool(false)
bool(true)
</pre>
<hr>

<h3>Yazı dizisi (String) İşlemleri</h3>

İki tane yazı dizisi işlemi vardır. İlki birleştirme işlemi ('.'), sonuçta sol ve sağ tarafındaki işlenenleri birleştirir. İkincisi ekleyerek atama ('.=') işlemidir. Atamanın sağındakiler sol taraftakinin peşine eklenir.
<pre>
&lt;?php
$a = "Hello ";
$b = $a . "World!"; // Şimdi $b "Hello World!" içerir

$a = "Hello ";
$a .= "World!";     // Şimdi $a "Hello World!" içerir
?&gt;
</pre>
<hr>

<h3>Dizi (Array) İşlemleri</h3>
<h3>Dizi (Array) İşlemleri Tablosu</h3>
<table class="yazi" border="1">
<tr><th>Örnek </th><th>Ad </th><th>Sonuç</th></tr>
<tr><td>$a + $b </td><td>Birlik (Union) </td><td>$a ve $b birliği.</td></tr>
<tr><td>$a == $b </td><td>Eşitlik (Equality) </td><td>Eğer $a ve $b anahtar/değer çifti aynısya TRUE döner.</td></tr>
<tr><td>$a === $b </td><td>Özdeşlik (Identity)</td><td>$a ve $b aynı anahtar/değer çifti aynı sıra ve türde ise TRUE döner.</td></tr>
<tr><td>$a != $b </td><td>Eşitsizlik (Inequality) </td><td>$a eşit değildir $b ise TRUE döner.</td></tr>
<tr><td>$a &lt;&gt; $b </td><td>Eşitsizlik (Inequality) </td><td>$a eşit değildir $b ise TRUE döner.</td></tr>
<tr><td>$a !== $b </td><td>Eşit Olmamak (Non-identity) </td><td>Eğer $a eşit değildir $b ise TRUE döner.</td></tr>
</table>
<br /><br />
'+' sağ tarafdaki diziden anahtarları sol taraftaki diziye eklerken aynı adlı anahtarlar eklenmez.
<pre>
&lt;?php
$a = array("a" =&gt; "apple", "b" =&gt; "banana");
$b = array("a" =&gt; "pear", "b" =&gt; "strawberry", "c" =&gt; "cherry");

$c = $a + $b; // $a ve $b birliğidir
echo "\$a ve \$b birliği: \n";
var_dump($c);

$c = $b + $a; // $b ve $a birliği
echo "\$b ve \$a birliği: \n";
var_dump($c);
?&gt;
</pre>
Çalıştırıldığında bu kodlama aşağıdakini yazar:
<pre>
Union of $a and $b:
array(3) {
  ["a"]=&gt;
  string(5) "apple"
  ["b"]=&gt;
  string(6) "banana"
  ["c"]=&gt;
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=&gt;
  string(4) "pear"
  ["b"]=&gt;
  string(10) "strawberry"
  ["c"]=&gt;
  string(6) "cherry"
}
</pre>

    

Karşılaştırma için dizi öğeleri eşitlik için aranır (eğer anahtar ve değer eşitse...)
<br /><br />
Dizileri karşılaştırma örneği
<pre>
&lt;?php
$a = array("apple", "banana");
$b = array(1 =&gt; "banana", "0" =&gt; "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?&gt;
</pre>
<hr>

<h3>Tür (Type) İşlemleri</h3>

PHP değişkeni delillerle bir sınıfın nesnesi olduğunu anlamak için 'instanceof' kullanılır.
<br /><br />
Sınıflarla "instanceof" kullanımı örneği
<pre>
&lt;?php
class MyClass
{
}
class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
bool(true)
bool(false)
</pre>

Değişkenin delillerle bir sınıfın nesnesi olduğunu anlamak için 'instanceof' kullanılır. O değişken kalıt olarak bir üst sınıftan gelir.

<br /><br />
Kalıt olan sınıflarda 'instanceof' kullanımı örneği
<pre>
&lt;?php
class ParentClass
{
}
class MyClass extends ParentClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?&gt;
</pre>
Bu örneğin çıktısı:
<pre>
bool(true)
bool(true)
</pre>

Son olarak bir arayüzü uyarlayansa değişkenin delillerle bir sınıfın nesnesi olduğunu anlamak için 'instanceof' kullanılır.
<br /><br />
Sınıflar için 'instanceof' kullanımı örneği
<pre>
&lt;?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
bool(true)
bool(true)
</pre>

'instanceof' çoğunlukla değişmez sınıf adıyla kullanılıyor olsa da, başka nesne ve yazı dizileriyle de kullanılabilir.
<br /><br />
Başka değişkenlerle 'instanceof' kullanma örneği
<pre>
&lt;?php
interface MyInterface
{
}
class MyClass implements MyInterface
{
}
$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';
var_dump($a instanceof $b); // $b is an object of class MyClass
var_dump($a instanceof $c); // $c is a string 'MyClass'
var_dump($a instanceof $d); // $d is a string 'NotMyClass'
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
bool(true)
bool(true)
bool(false)
</pre>
PHP 5.1.0 sürümünden önce 'instanceof' eğer sınıf adı bulunamazsa __autoload() çağırıdı. Ek olarak eğer sınıf yüklenemezse hata verirdi. Bu sorun dynamic sınıf gösterimiyle  ya da sınıf adını içeren yazı dizisi değişkeniyle geçilir.
<br /><br />
Sınıfadı bakma sırasındaki hataları önlemek için 'instanceof' kullanımı
<pre>
&lt;?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // burada hata oluşmaz
?&gt;
</pre>

Yukarıdaki örneğin çıktısı şöyledir:

<pre>
bool(false)
</pre>

PHP 5 de 'instanceof' işlemi kullanıma sunuldu. Bundan önce is_a() kullanılırdı. Şimdi artık kullanılmamaktadır.
<br /><br />

</div>
         </div>
         <span><img src="img/notebook1.gif"><br /></span>
       </div>
    </td><td valign="top">
       <div id="sagtaraf">
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x600, created 1/16/08
google_ad_slot = "7007060807";
google_ad_width = 120;
google_ad_height = 600;
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x240, created 1/25/08
google_ad_slot = "8433790203";
google_ad_width = 120;
google_ad_height = 240;
google_cpa_choice = ""; // on file
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

       </div>
    </td></tr>
    </table>
</div>
</body>
</html>
