<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PHP kökler - Programlama</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META content=0 http-equiv=expires>
<link rel="stylesheet" type="text/css" href="main.css" media="screen" />
<script language="JavaScript" src="../js/browser.js"> </script>
<script type="text/javascript">
function myvoid()
{
}
function ackapa(no)
{
var bolum="secim"+no;
    target=document.getElementById(bolum);
    if(target.style.display == "inline") {
         target.style.display = "none";
    } else {
         target.style.display = "inline";
    }
}
</script>
</head>

<body onLoad="ayarla();">
<div id="taban">
    <table cellpadding="0" cellspacing="0" width="100%">
    <tr><td valign="top">
       <div id="soltaraf">
           <a href="../index.php"><img src="../img/aybim.png" border="0"></a><br /><br />
           <div class="menublock">
               <a href="phptxt7.html" class="nav">Php Kök</a>
               <a href="phpkok1.html" class="sub">ext_skel</a><br 7>
               <a href="phpkok2.html" class="sub">UNIX:config.m4</a><br 7>
               <a href="phpkok3.html" class="sub">Win:config.w32</a><br 7>
               <a href="phpkok4.html" class="sub">zend_module</a><br 7>
               <a href="phpkok8.html" class="sub">Zorunluluklar</a><br 7>
               <a href="phpkok9.html" class="sub">Hazırlama</a><br 7>
               <a href="phpkok10.html" class="sub">İskelet doldurma</a><br 7>
               <a href="phpkok11.html" class="sub">Hazılama</a><br 7>
               <a href="phpkok12.html" class="sub">Denemeler</a><br 7>
               <a href="phpkok13.html" class="sub">Paket Yaratma</a><br 7>
               <a href="phpkok14.html" class="sub">pdo_dbh_t</a><br 7>
               <a href="phpkok15.html" class="sub">pdo_stmt_t</a><br 7>
               <a href="phpkok16.html" class="sub">Değişmezler</a><br 7>
               <a href="phpkok17.html" class="sub">Hatalar</a><br 7>
               <a href="phpkok18.html" class="sub">PHP uzantı API</a><br 7>
               <a href="phpkok19.html" class="sub">Zend API: </a>
           </div>
       </div>
    </td><td valign="top">
       <center><h2>PHP Hyperlink Preprocessor</h2></center>
       <div id="ortataraf">
<!-- cascading style sheets ardaşık stil sayfaları -->
         <span><img src="img/notebook1.gif"></span>
         <div id="canvas">
<div id="sag"><span class="yazi">10 Mart 2008</span></div>
<div id="bdy" class="yazi">
<h3>PHP uzantıları yazarları için Akarların API bilgisi</h3>
<h3>Özet</h3>

PHP akar API bilgisi, PHP uzantılarında dosyaları ve soketleri ele almak için tekil bir yaklaşım sunar. Amaç sırada işler için standart işlevlerle tek API kullanmaktır. Akarların API bilgisi uzantınızın dosyalara erişimini, soketleri, URL adreslerini, bellek ve kodlama tanımlı nesneleri ele alır. Çalışırken genişleyen akar API bilgisi yeni akarları kaydetmek için dinamik yüklenebilen modüllere (ve kodlamalara) izin verir.
<br /><br/>
Akar API bilgisinin hedefi geliştiricilere ortamı (dosya açmak, URL adresleri ve diğer akabilir veri kaynaklarına erişim) daha kolay yapmaktır. Tekil API bilgisinin yararı kolay anlaşılabilir olmasıdır. API daha çok ANSI C ailesi işlevlerine benzer (birçok ana işlevde aynı yazım ve anlam kuralı vardır). Böylece C programcılarının akarlarla yakınlıkları oluşmuş olur.
<br /><br/>
Akar API bilgisi değişik katmanlarda çalışır: ana katmanda, API akabilir veri kaynaklarını göstermek için php_stream nesnelerini tanımlar. Biraz üst katmanda API  php_stream_wrapper nesnesini tanımlar. Alttaki API bilgilerini çevirerek verileri ve meta verileri URL adreslerinden almak için kullanılır. Pekçok akar yaratma işlevlerinde de kullanılan ek içerik parametresi akar açarı yöntemine (stream_opener) çevricinin ince ayarını gösteren değer olarak aktarılır.
<br /><br/>
Bir akar, birkez açıldı mı, üzerine uygulanan birçok filitreyle karşılaşır. Bunlar akardan okunan/akara yazılan veriyi işler.
<br /><br/>
Akarlar başka dosya göstergelerine çevrilebilir. Böylece üçüncü partilerin kitaplıklarını büyük bir sorunla karşılaşılmadan kullanılabilir. Bu kitaplıkların URL adresindeki veriyi doğrudan kullanmalarına da izin verir. Eğer sisteminizin fopencookie() ya da funopen() işlevleri varsa, herhangi bir PHP akarını herhangi bir kitaplığa (ANSI stdio kullanan) geçirebilirsiniz.
<br /><br/>
    Not: Buradaki işlevler PHP kaynak kodlarında kullanmak içindir. Bunlar PHP işlevleri değildir. Kulalnıcının akarlarına ilişkin işlevler Akarlar Kitapçığında bulunabilir.

<h3>Akarların Temeli</h3>

Akarları kullanmak ANSI stdio kullanmak gibidir. En önemli fark, başlamak için akar göstergesini nereden bulacağınızdır. Birçok durumda, php_stream_open_wrapper() kulalnılır. Bu aşağıdaki örnekte olduğu gibi fopen benzeri kullanımı vardır.

<h3>Örnek-1 simple stream example that displays the PHP home page</h3>
<pre>
php_stream * stream = php_stream_open_wrapper("http://www.php.net",
                          "rb", REPORT_ERRORS, NULL);
if (stream) {
    while(!php_stream_eof(stream)) {
        char buf[1024];
        
        if (php_stream_gets(stream, buf, sizeof(buf))) {
            printf(buf);
        } else {
            break;
        }
    }
    php_stream_close(stream);
}
</pre>
Aşağıdaki tablo daha genel ANSI stdio işlevlerinin eşdeğerlerini gösterir. Ayrıca belirtilmezse anlamları benzerdir.
<h3>ANSI stdio equivalent functions in the Streams API ANSI Stdio</h3>
<table class="yazi">
<tr><td>İşlev</td><td>PHP Akar İşlevi </td><td>Açıklama</td></tr>
<tr><td>fopen </td><td>php_stream_open_wrapper </td><td>Akarların ek parametreleri vardır</td></tr>
<tr><td>fclose </td><td>php_stream_close </td><td></td></tr>
<tr><td>fgets </td><td>php_stream_gets </td><td></td></tr>
<tr><td>fread </td><td>php_stream_read </td><td>nmemb parametresinin değerinin 1 olduğu varsayılır, o zaman prototip read(2) gibi görünür</td></tr>
<tr><td>fwrite </td><td>php_stream_write </td><td>nmemb parametresinin değerinin 1 olduğu varsayılır, o zaman prototip write(2) gibi görünür</td></tr>
<tr><td>fseek </td><td>php_stream_seek </td><td></td></tr>
<tr><td>ftell </td><td>php_stream_tell </td><td></td></tr>
<tr><td>rewind </td><td>php_stream_rewind </td><td></td></tr>
<tr><td>feof </td><td>php_stream_eof </td><td></td></tr>
<tr><td>fgetc </td><td>php_stream_getc </td><td></td></tr>
<tr><td>fputc </td><td>php_stream_putc </td><td></td></tr>
<tr><td>fflush </td><td>php_stream_flush </td><td></td></tr>
<tr><td>puts </td><td>php_stream_puts </td><td>Anlamı aynı puts gibidir (fputs değil)</td></tr>
<tr><td>fstat </td><td>php_stream_stat </td><td>Akarların daha zengin "stat" yapısı vardır</td></tr>
</table>
<h3>Kaynak olarak Akarlar</h3>

Tüm akarlar yaratıldıklarında kaynak olarak kaydedilirler. Bazı kritik hatalar da olsa düzgün temizleneceklerini garanti eder. PHP'de tüm sistem işlevleri akarların kaynaklarıyladır. Bunun anlamı sizin uzantınız da doğru PHP dosyalarının göstergelerini parametre olarak kabul edebilir ve kendi işlevlerinden akarları döndürebilir. Akarların API bilgisi bunu sorunsuz çözümler.
<h3>Örnek:2 Bir akarı parametre olarak nasıl kabul edilir</h3>
<pre>
PHP_FUNCTION(example_write_hello)
{
    zval *zstream;
    php_stream *stream;
    
    if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,
                                         "r", &zstream))
        return;
    
    php_stream_from_zval(stream, &zstream);

    /* şimdi akarı kullanabilirsiniz. Ama onun sahibi değilsiniz
        kodlama sahibidir. Bunun anlamı akarı kapatmamalısınız
        o zaman PHP kırılır */

    php_stream_write(stream, "hello\n");
        
    RETURN_TRUE();
}
</pre>
<h3>Örnek-3 Bir akar işlevde nasıl döndürülür</h3>
<pre>
PHP_FUNCTION(example_open_php_home_page)
{
    php_stream *stream;
    
    stream = php_stream_open_wrapper("http://www.php.net",
                                     "rb", REPORT_ERRORS, NULL);
    
    php_stream_to_zval(stream, return_value);

    /* Bu noktadan sonra, akar kodlama tarafından sahiplenilir.
       Burada kapatırsanız PHP kırılır */
}
</pre>
Since streams are automatically cleaned up, it's tempting to think that we can get away with being sloppy programmers and not bother to close the streams when we are done with them. Although such an approach might work, it is not a good idea for a number of reasons: streams hold locks on system resources while they are open, so leaving a file open after you have finished with it could prevent other processes from accessing it. If a script deals with a large number of files, the accumulation of the resources used, both in terms of memory and the sheer number of open files, can cause web server requests to fail. Sounds bad, doesn't it? The streams API includes some magic that helps you to keep your code clean - if a stream is not closed by your code when it should be, you will find some helpful debugging information in you web server error log.
Akarlar otomatik temizlendiğinden, 
<br /><br />
    Not: Always use a debug build of PHP when developing an extension (--enable-debug when running configure), as a lot of effort has been made to warn you about memory and stream leaks. 
<br /><br />
Bazı durumlarda, isteğin sürdüğü zaman içerisinde log ya da tarama dosyası gibi kullanımlar için akarı açık tutmak yararlı olabilir. Bu tür akarı temizlemek için kod yazmak zor değildir ama kesin olarak gerekmeyen kısa olmayan bir yazılımdır. Kod yazma sıkıntısından korunmak için, bir akarı otomatik temizlenme için işaretleyebilirsiniz. Bunun anlamı, akarın API bilgisi bir uyarı üretmeden otomatik temizlemeyi yapar. Bunun için php_stream_auto_cleanup() kullanabilirsiniz.
<h3>Akarların açma (open) seçimlikleri</h3>

Değişmezler akar fabrikası işlevlerinin işlemlerini etkiler.
<dl>
<dt>IGNORE_PATH
    <dd>Bu akarlar için varsayılan seçimliktir. istenen dosya için ekleme yolu include_path gerekmediğini bildirir.
    </dd></dt>
<dt>USE_PATH
    <dd>İstenen dosya için ekleme yolu "include_path" aranacaktır.
    </dd></dt>
<dt>IGNORE_URL
    <dd>İstenen kaydedilmiş URl kapatıcıların akar açılırken dikkate alınmamasıdır. Diğer URL olmayan kapatıcılarda yolu açarken dikkate alınacaktır. Bunun tersi olacak bir durum kodu yoktur. Akar API bilgisi kaydedilen kapatıcıların hepsini kullanır.
    </dd></dt>
<dt>IGNORE_URL_WIN
    <dd>Windows sistemlerinde, bu IGNORE_URL anlamına gelir. Tüm diğer sistemlerde, bu durum kodunun bir anlamı yoktur.
    </dd></dt>
<dt>ENFORCE_SAFE_MODE
    <dd>Burada istenen, sistemde yer alan akar uygulaması "safe_mode" kontrollarının yapılmasıdır. Bu durum kodunu unutmak "safe_mode" kontrollarının atlanmasına neden olur. PHP işleminin erişme hakkı olan tüm dosyaları açmasına izin verilir.
    </dd></dt>
<dt>REPORT_ERRORS
    <dd>Eğer bu durum kodu ayarlıysa ve dosyanın ya da URL adresinin açılması sırasında bir hata olmuşsa, akar API bilgisi sizin için php_error işlevini çağırır. Bu kullanışlıdır. Çünkü dosya yolu kullanıcı adı/şifre bilgisini içerebilir. Tarayıcının çıktısında bu bilgi görünlenmiyor olabilir (bu aslında önemli bir güvenlik sorunudur). Akarın API bilgisi hatayı başlattığında, önce dosya yolundan kullanıcı adı/şifre bilgisini sıyırır. Böylece hata kodu tarayıcı ekranında görüntülenir.
    </dd></dt>
<dt>STREAM_MUST_SEEK
    <dd>
Sizin uzantınızın gerçekten akarın çevresinde rastgele aranması olanağı varsa bu durum kodu kullanışlıdır. Bazı akarlar yerel yapıda aranabilir değildir. O halde bu akar API bilgisini arama yapmaya uygun akar olup olmadığına baklaya yarar. Eğer aranma yapılamazsa, akarı aranma yapılabilen geçici alana taşınır (geçici dosya ya da bellek akarı olabilir). Bilin ki bu aranma işleminden sonra yazmaya kalkılınca kullanışlı değildir. Çünkü kullandığınız akar gerçek kaynaklara bağlanmış olamayabilir.
         </div>
<div id="sag"> <B><A HREF="javascript:history.back()">Dönüş</A></B> </div>
</div>
         </div>
         <span><img src="img/notebook1.gif"><br /></span>
       </div>
    </td><td valign="top">
       <div id="sagtaraf">
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x600, created 1/16/08
google_ad_slot = "7007060807";
google_ad_width = 120;
google_ad_height = 600;
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x240, created 1/25/08
google_ad_slot = "8433790203";
google_ad_width = 120;
google_ad_height = 240;
google_cpa_choice = ""; // on file
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

       </div>
    </td></tr>
    </table>
</div>
</body>
</html>
