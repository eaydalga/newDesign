<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PHP - Sınıflar ve Nesneler (PHP 5) Bölüm1 </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META content=0 http-equiv=expires>
<link rel="stylesheet" type="text/css" href="main.css" media="screen" />
<script language="JavaScript" src="../js/browser.js"> </script>
<script type="text/javascript">
function myvoid()
{
}
</script>
</head>

<body onLoad="ayarla();">
<div id="taban">
    <table cellpadding="0" cellspacing="0" width="100%">
    <tr><td valign="top">
       <div id="soltaraf">
           <a href="../index.html"><img src="../img/aybim.png" border="0"></a><br /><br />
           <div class="menublock">
               <font color="#8e9ccb"><h3>Tanımlar</h3></font>
               <a href="javascript:myvoid();" class="nav">Başlarken</a>
               <a href="phptxt11.html" class="sub">ilk Anlatım</a>
               <a href="javascript:myvoid();" class="nav">Kurulumlar</a>
               <a href="phptxt21.html" class="sub">Genel Kurulum</a><br />
               <a href="phptxt22.html" class="sub">UNIX Kurulumu</a><br />
               <a href="phptxt23.html" class="sub">OSX Kurulumu</a><br />
               <a href="phptxt24.html" class="sub">Wins Kurulumu</a>
               <a href="javascript:myvoid();" class="nav">Dil Kuralları</a>
               <a href="phptxt31.html" class="sub">Temel yazım</a><br />
               <a href="phptxt32.html" class="sub">Tipler</a><br />
               <a href="phptxt33.html" class="sub">Değişkenler</a><br />
               <a href="phptxt34.html" class="sub">Değişmezler</a><br />
               <a href="phptxt35.html" class="sub">Deyimler</a><br />
               <a href="phptxt36.html" class="sub">İşlemler</a><br />
               <a href="phptxt37.html" class="sub">Kontrol Yapıları</a><br />
               <a href="phptxt38.html" class="sub">İşlevler</a><br />
               <a href="phptxt39.html" class="sub">Sınıflar Nesneler</a><br />
               <a href="phptxt391.html" class="sub">Ad uzayı</a><br />
               <a href="phptxt392.html" class="sub">İstisnalar</a>
               <a href="javascript:myvoid();" class="nav">Güvenlik</a>
               <a href="phptxt41.html" class="sub">Giriş</a><br />
               <a href="phptxt42.html" class="sub">Genel bilgi</a><br />
               <a href="phptxt43.html" class="sub">CGI iklisi</a><br />
               <a href="phptxt44.html" class="sub">Apache modülü</a><br />
               <a href="phptxt45.html" class="sub">Dosyadüzeni</a><br />
               <a href="phptxt46.html" class="sub">Veritabanı</a><br />
               <a href="phptxt47.html" class="sub">Hatalar</a><br />
               <a href="phptxt48.html" class="sub">Diğerleri</a><br />
               <a href="javascript:myvoid();" class="nav">Özellikler</a>
               <a href="phptxt51.html" class="sub">HTTP Şifresi</a><br />
               <a href="phptxt52.html" class="sub">Çerezler</a><br />
               <a href="phptxt53.html" class="sub">Oturumlar</a><br />
               <a href="phptxt54.html" class="sub">XForm</a><br />
               <a href="phptxt55.html" class="sub">DosyaYükleme</a><br />
               <a href="phptxt56.html" class="sub">UzakDosyalar</a><br />
               <a href="phptxt57.html" class="sub">Bağlantılar</a><br />
               <a href="phptxt58.html" class="sub">VTBağlantısı</a>
               <font color="#8e9ccb"><h3>Gelişmiş</h3></font>
               <a href="../phpfunc/islevler.html" class="nav">İşlevler</a>
               <a href="phptxt7.html" class="nav">Php Kökü</a>
               <a href="phptxt8.html" class="nav">Ekler</a>
           </div>
       </div>
    </td><td valign="top">
       <center><h2>PHP Hyperlink Preprocessor</h2></center>
       <div id="ortataraf">
<!-- cascading style sheets ardaşık stil sayfaları -->
         <span><img src="img/notebook1.gif"></span>
         <div id="canvas">
<div id="sag"><span class="yazi">2 Şubat 2008</span></div>
<h2>Sınıflar ve Nesneler (PHP 5) Bölüm1</h2>
<div id="bdy" class="yazi">
    
<h3>Giriş</h3>

PHP 5 içinde tümüyle yeni bir nesne modeli (Object Model) vardır. PHP nin nesneleri ele alışı tümüyle yeniden yazılmışıt. Verimlilik arttırılmış, yeni özellikler eklenmiştir.
<hr>

<h3>Temel</h3>
<b>class (sınıf)</b>

Every class definition begins with the keyword class, followed by a class name, which can be any name that isn't a reserved word in PHP. Followed by a pair of curly braces, which contains the definition of the classes members and methods. A pseudo-variable, $this is available when a method is called from within an object context. $this is a reference to the calling object (usually the object to which the method belongs, but can be another object, if the method is called statically from the context of a secondary object). This is illustrated in the following examples:
Her sınıf tanımı anahtar sözcük "class" ile başlar. Peşinden sınıf adı gelir. PHP içinde saklı sözcük olmayan her kelime bu amaç için kullanılabilir. Ğeşinden bir çift kıvrımlı parantez kullanılır. Parantezlerin içinde sınıfın üyeleri ve yöntemleri bulunur. Değişkenimsi $this yöntem nesne içinden çağrıldığında vardır. Aslında $this çağıran nesne için bir göstergedir (genelde yöntemin ait olduğu nesnedir ama eğer yöntem durağan olarak ikincil sınıftan çağrılırsa, başka bir nesne de olabilir). Aşağıdaki örnekte bu konu anlatılmıştır.
<br /><br />
Nesne tabanlı dilde $this değişkeni örneği
<pre>
&lt;?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this (';
            echo get_class($this);
            echo ") tanımladı\n";
        } else {
            echo "\$this tanımsız.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a-&gt;foo();
A::foo();
$b = new B();
$b-&gt;bar();
B::bar();
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
$this (a) tanımladı
$this tanımsız.
$this (b) tanımladı
$this tanımsız.
</pre>

Basit Sınıf tanımı örneği
<pre>
&lt;?php
class SimpleClass
{
    // üye tanımı
    public $var = 'a default value';

    // yöntem tanımı
    public function displayVar() {
        echo $this-&gt;var;
    }
}
?&gt;
</pre>
Varsayılan değer değişmez deyim olmalıdır. Örneğin bir değişken, sınıf üyesi ya da işlev olamaz.
<br /><br />
Sınıf üyelerinin varsayılan değerleri örneği
<pre>
&lt;?php
class SimpleClass
{
    // geçersiz üye tanımı:
    public $var1 = 'hello '.'world';
    public $var2 = &lt;&lt;&lt;EOD
hello world
EOD;
    public $var3 = 1+2;
    public $var4 = self::myStaticMethod();
    public $var5 = $myVar;

    // geçerli üye tanımı:
    public $var6 = myConstant;
    public $var7 = self::classConstant;
    public $var8 = array(true, false);
}
?&gt;
</pre>

    Not: Sınıfları ve nesneleri ele almak için bazı güzel işlevler vardır. Bunun için Sınıf/Nesne işlevlerine bakmalısınız.

<b>new (yeni)</b>

Bir sınıf kopyası yaratmak için yeni bir nesne yaratılmalı ve bir değişkene atanmalıdır. Bir nesne yenisi yaratılırken her zaman atanır. Ama nesnenin yapımcısı tanımlanmış ve hatada sonu başklığa fırlatırsa atama olmaz. Kopyalanmadan önce sınıflar tanımlanmış olmalıdır (ve bazı koşullarda bu bir gereksinimdir).
<br /><br />
Bir kopya yaratma örneği
<pre>
&lt;?php
$instance = new SimpleClass();
?&gt;
</pre>
Sınıf içeriğinde, yeni nesneyi kendisi ve yeni babası (üstü) ile yaratmak olabilir.
<br /><br />
Bir sınıfın kopyasını yeni bir değişkene atarken, yeni değişken atandığı nesnenin kopyasına erişir. Bu davranış kopyaları işleve geçirirken de aynıdır. Nesnenin kopyası onu klonlayarak yaratırç
<br /><br />
Nesne Ataması örneği
<pre>
&lt;?php
$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned bu değeri alır';

$instance = null; // $instance ve $reference null olur

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=&gt;
     string(30) "$assigned bu değeri alır"
}
</pre>

<b>extends (uzantılar)</b>

Bir sınıf, başka bir sınıfın yöntemlerini ve üyelerini 'extends' anahtar kelimesiyle kalıt olarak alabilir. Çoklu sınıf uzantısı olanaksızdır. Bir sınıf ancak bir temel sınıfı katıl olarak alabilir.
<br /><br />
Katılsal yöntem ve üyeler üzerine yazılabilir. Ancak baba sınıfı son olan bir yöntem tanımlarsa (baba sınıfta tanımlanan birini aynı yerde yeniden tanımlarsa) bunu söyleyemeyiz. Üzerine yazma yöntemine ya da statik üyelere parent:: ile gösterilerek erişilebilir.
<br /><br />
Basit Sınıf kalıt örneği
<pre>
&lt;?php
class ExtendClass extends SimpleClass
{
    // baba (üst) yöntemi yeniden tanımlama
    function displayVar()
    {
        echo "Sınıfı gelişletme\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended-&gt;displayVar();
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
Sınıfı geliştirme
a default value
</pre>
<hr>

<h3>Nesneleri Otomatik Yükleme (Autoloading Objects)</h3>

Nesne-tabanlı uygulama yazan birçok geliştirici her sınıf tamını için bir PHP dosyası yaratır. Bunun en rahatsız edici özelliği her kodlamanın başındaki uzun ekleme (include) listesidir (her sınıf için en bir tane).
<br /><br />
PHP 5 içinde artık buna gerek yoktur. Bir tane __autoload işlevi tanımlarsınız. Bir sınıfı kullanmak istediğinizde, tanımlanmamış sınıflar için bu işlev otomatik çağrılır. Bu işlevle kodlama amkinesi hata vermen önce bir fırsata daha erişmiş olur.
<br /><br />
    Not: __autoload işlevindeki fırlatına başkalıklar yakalama bloğu tarafından yakalanamaz ve kritik hataya döner.
<br /><br />
    Not: Eğer PHP CLI etkileşimli konumda çalışırsa otomatik yükleme geçerli olmaz.
<br /><br />
    Not: call_user_func() içinde sınıf adı kullanılırsa, o zaman bazı tehlikeli karakterler (../ gibi) içerebilir. Önerilen, kullanıcı girişlerinin bu tür işlevlerde kullanılmamasıdır ya da girişi __autoload/( içinde kontrol edilmelidir.
<br /><br />
Otomatik Yükleme örneği
<br /><br />
Bu örnek MyClass1 veMyClass2 sınıflarını MyClass1.php ve MyClass2.php dosyalarından otomatik yüklemeye çalışır.
<pre>
&lt;?php
function __autoload($class_name) {
    require_once $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 
?&gt;
</pre>
<hr>

<h3>Yapıcılar ve Bozucular (Constructors and Destructors)</h3>
<h3>Yapıcı (Constructor)</h3>
<pre>
void __construct ([ mixed $args [, $... ]] )
</pre>
<br /><br />
PHP 5 geliştiricilerin sınıflar için yapıcı yöntem tanımlamaya izin verir. yapıcı yöntemi olan sınıflar, bu yöntemi her yeni yaratılan nesnede çağırır. Böylece kullanılmadan önce gereken ilklemeler için durum uygun olur.
<br /><br />
    Not: Eğer çocuk sınıf bir yapıcıyı tanımlarsa baba yapıcılar içerden çağrılmazlar. Baba yapıcıyı çalıştırmak için çocuk yapıcı içinen babayı parent::__construct() ile çağırmak gerekir.
<br /><br />
Yeni belirgin yapıcı örneği
<pre>
&lt;?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

$obj = new BaseClass();
$obj = new SubClass();
?&gt;
</pre>
Eskiye uyum açısından, PHP 5 bir sınıf için  __construct() işlevini bulamazsa, sınıf adıyla eski tür yapıcı işlevi arar. Etkin olarak söylenebilir ki, uyumluluk açısından sınıfın __contruct() adlı bir sınıfı olursa anlamlıdır.
<h3>Bozucu (Destructor)</h3>
<pre>
void __destruct ( void )
</pre>
------------------------------------------------------------------------------
PHP 5 introduces a destructor concept similar to that of other object-oriented languages, such as C++. The destructor method will be called as soon as all references to a particular object are removed or when the object is explicitly destroyed or in any order in shutdown sequence.
PHP 5 bozucu kavramını aynı nesnel tabanlı dillerde (C++ gibi) olduğu gibi sunar. Bozucu yöntem çağrılır bu nesneye ilişkin adresler kaldırılır ya da nesne açıkça bozdurulur ya da herhangi biçimde kapanış sıralamasındadır.
<br /><br />
Bozucu Örneği
<pre>
&lt;?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?&gt;
</pre>

Yapıcılarda olduğu gibi baba bozucu makine tarafından içsel biçimde çağrılmaz. Baba bozucuyu çalıştırmak için bozucu gövdesinde parent::__destruct() açıkça çağrılmalıdır.
<br /><br />
    Not: Kodlama kapanışında çağrılan bozucular HTTP başlıklarını göndermiş olurlar. Kodlamanın kapanış admındaki o an çalışılan dosya yolu bazı SAPI'lerde farklı olabilir (e.g. Apache).
<br /><br />
    Not: Bozucudan bir başkalığı fırtlatma girişimi (kodlama kapanışını anında çağrılır) kritik bir hataya neden olur.
<hr>

<h3>Görünürlük (Visibility)</h3>

The visibility of a property or method can be defined by prefixing the declaration with the keywords: public, protected or private. Public declared items can be accessed everywhere. Protected limits access to inherited and parent classes (and to the class that defines the item). Private limits visibility only to the class that defines the item.
<h3>Üyelerin Görünürlüğü (Members Visibility)</h3>

Sınıf üyeleri halka açık (public), özel (private) ya da korunmalı (protected) tanımlanırlar.
<br /><br />
Üye tanımı örneği
<pre>
&lt;?php
/**
 * MyClass Tanımlama
 */
class MyClass
{
    public $public = 'Halka açık';   // oublic
    protected $protected = 'Korunmalı'; // protected
    private $private = 'Özel';       // private

    function printHello()
    {
        echo $this-&gt;public;
        echo $this-&gt;protected;
        echo $this-&gt;private;
    }
}

$obj = new MyClass();
echo $obj-&gt;public; // çalışır
echo $obj-&gt;protected; // Kritik Hata
echo $obj-&gt;private; // Kritik Hata
$obj-&gt;printHello(); // Halka açık, Korunmalı ve Özel gösterme


/**
 * MyClass2 Tanımlama
 */
class MyClass2 extends MyClass
{
    // Biz halka açık ve korunmalı yöntemleri yeniden tanımlarız
    // ama özel olanı tanımlayamayız.
    protected $protected = 'Korunmalı2';

    function printHello()
    {
        echo $this-&gt;public;
        echo $this-&gt;protected;
        echo $this-&gt;private;
    }
}

$obj2 = new MyClass2();
echo $obj2-&gt;public; // Çalışır
echo $obj2-&gt;private; // Tanımsız
echo $obj2-&gt;protected; // Kritik Hata
$obj2-&gt;printHello(); // Halka açık, Korunmalı2, Tanımsız gösterme

?&gt;
</pre>
    Not: PHP 4 yöntemi olan değişkeni "var" anahtar sözcüğüyle tanımlama, uyum nedenleriyle hala geçerlidir ("publi" kelimesine eşdeğer olarak). PHP 5 içinde 5.1.3 sürümünden önce kullanımı E_STRICT uyarısı üretirdi.

<h3>Yöntem Görünürlüğü (Method Visibility)</h3>

Class methods must be defined with public, private, or protected. Methods without any declaration are defined as public.
<br /><br />
Yöntem tanılama örneği
<pre>
&lt;?php
/**
 * MyClass Tanımlama
 */
class MyClass
{
    // Yapıcılar halka açık olmalı (public)
    public function __construct() { }

    // Halka açık (public) yöntem tanımla
    public function MyPublic() { }

    // Korunmalı (protected) yöntem tanımla
    protected function MyProtected() { }

    // Özel (private) yöntem tanımlama
    private function MyPrivate() { }

    // Bu halka açık (public)
    function Foo()
    {
        $this-&gt;MyPublic();
        $this-&gt;MyProtected();
        $this-&gt;MyPrivate();
    }
}

$myclass = new MyClass;
$myclass-&gt;MyPublic(); // çalışır
$myclass-&gt;MyProtected(); // Kritik Hata verir
$myclass-&gt;MyPrivate(); // Kritik Hata verir
$myclass-&gt;Foo(); // Halka açık (Public), Korunmalı (Protected) ve
                    // özel (Private) çalışır


/**
 * MyClass2 Tanımala
 */
class MyClass2 extends MyClass
{
    // Bu halka açıktır (public)
    function Foo2()
    {
        $this-&gt;MyPublic();
        $this-&gt;MyProtected();
        $this-&gt;MyPrivate(); // Kritik Hata
    }
}

$myclass2 = new MyClass2;
$myclass2-&gt;MyPublic(); // çalışır
$myclass2-&gt;Foo2(); // Halka açık (Public), Korunmalı (Protected) ve
                      // özel (Private) çalışır

class Bar 
{
    public function test() {
        $this-&gt;testPrivate();
        $this-&gt;testPublic();
    }

    public function testPublic() {
        echo "Bar::halkaAcikDene\n";
    }
    
    private function testPrivate() {
        echo "Bar::ozelDene\n";
    }
}

class Foo extends Bar 
{
    public function testPublic() {
        echo "Foo::halkaAcikDene\n";
    }
    
    private function testPrivate() {
        echo "Foo::ozelDene\n";
    }
}

$myFoo = new foo();
$myFoo-&gt;test(); // Bar::testPrivate 
                // Foo::testPublic
?&gt;
</pre>
<hr>

<h3>Kapsam Çözüm İşlemi (Scope Resolution Operator) (::)</h3>

Kapsam çözümleme işlemi (Paamayim Nekudotayim da denir) ya da çift iki nokta üst üste, bir sınıfın durağan, değişmez ve üzerine yazılan üye (ya da yöntem) erişimi için bir biçimdir.
<br /><br />
Sınıf tanımı dışından bunlara erişirken, sınıfın adı kullanılır.
<br /><br />
PHP 5.3.0 sürümünden sonra bir sınıfa erişim değişkenle de olabilir. Anahtar sözcükler "self", "parent" ya da "static" dinamik sınıf gösteriliminde kullanılamaz.
<br /><br />
"Paamayim Nekudotayim" çift iki nokta üst üste için tuhaf bir seçim gibi düşünülebilir Zend makinesi yazılırken takımın verdiği bu isim aslında Hebrew dilinde çift iki nokta üst üste demektir.
<br /><br />
Sınıf tanımı dışından :: örneği
<pre>
&lt;?php
class MyClass {
    const CONST_VALUE = 'Bir değişmez değer';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE;

echo MyClass::CONST_VALUE;
?&gt;
</pre>

İki özel anahtar sözcük (parent ve self) üyelere ve yöntemlere sınıf tanımı içinden erişimde kullanılır.
<br /><br />
sınıf tanımı içinden :: kullanım örneği
<pre>
&lt;?php
class OtherClass extends MyClass
{
    public static $my_static = 'static var';

    public static function doubleColon() {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

$classname = 'OtherClass';
echo $classname::doubleColon();

OtherClass::doubleColon();
?&gt;
</pre>

Eğer sınıf uzantıları yöntemin baba tanımının üzerine yazarsa, PHP babanın yöntemini çağarmaz. O uzatılmış sınıfta kalır. Bu Yapıcılara ve Bozuculara da uygulanır. Taşma (overloading) ve Tılsımlı (magic) yöntem tanımları da kapsam içindedir.
<br /><br />
Babanın yöntemini çağırma örneği
<pre>
&lt;?php
class MyClass
{
    protected function myFunc() {
        echo "MyClass::myFunc()\n";
    }
}

class OtherClass extends MyClass
{
    // Override parent's definition
    public function myFunc()
    {
        // Fakat hala baba işlevini çağırır
        parent::myFunc();
        echo "OtherClass::myFunc()\n";
    }
}

$class = new OtherClass();
$class-&gt;myFunc();
?&gt;
</pre>
<hr>

<h3>Durağan Anahtar Sözcük (Static Keyword)</h3>

Sınıf üyelerini ya da yöntemlerini durağan tanımlama sınıfın kurulmasını gerektirmeden erişimi sağlar. Bir üye durağan tanımlanınca, sınıf kopyasıyal erişilemez (ama durağan bir yönteme erişilebilir).
<br /><br />
PHP 4 ile uyum açısından, görünürlük tanımı kullanılmazsa, üye ve yöntem halka açık tanımlanmış varsayılır.
<br /><br />
Durağan yöntemler nesnenin kopyası yaratılmadan da kullanılabildiğinden, değişkenimsi $this durağan tanımlanan yöntemin içinde geçersizdir.
<br /><br />
Durağan özelliklere nesneyle -&gt; işlemi kullanılarak erişilemez.
<br /><br />
Durağan olmayan bir yöntemi durağanmış gibi çağırmak E_STRICT düzeyinde uyarıya nedne olur.
<br /><br />
PHP 5.3.0 ve sonrasında değişkenle bir sınıfı adreslemek olanağı vardır. 'self', 'parent' ya da 'static' dinamik sınıf adreslemesinde kullanılamaz.
<br /><br />
Durağan üye örneği
<pre>
&lt;?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo
{
    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo-&gt;staticValue() . "\n";
print $foo-&gt;my_static . "\n";  // Tanımsız "Property" my_static 

print $foo::$my_static . "\n";
$classname = 'Foo';
print $classname::$my_static . "\n";

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar-&gt;fooStatic() . "\n";
?&gt;
</pre>
<br />
Durağan yöntem örneği
<pre>
&lt;?php
class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
$classname = 'Foo';
$classname::aStaticMethod();
?&gt;
</pre>
<hr>

<h3>Sınıf Değişmezleri (Class Constants)</h3>

Değişmezleri sınıf başına tanımlama olanğı onların değiştirilmeden kalmalarını sağlar. Değişmezler normal değişkenlerden ayrıdır. Onları kullanırken ya da tanımlarken başına $ işareti eklenmez.
<br /><br />
Değer her zaman değişmez deyim olmalıdır. Değişken, sınıf, matematik işlem sonucu ya da işlev çağırma olamaz.
<br /><br />
PHP 5.3.0 sürümü ve sonrası için değişken kullanarak bir sınıfı adresleme olanağı vardır. 'self','parent' ya da 'static' dinamik sınıf gösteriliminde kullanılamaz.
<br /><br />
Değişmezleri tanımlama ve kullanma örneği
<pre>
&lt;?php
class MyClass
{
    const constant = 'değişmez değer';

    function showConstant() {
        echo  self::constant . "\n";
    }
}

echo MyClass::constant . "\n";

$classname = "MyClass";
echo $classname::constant . "\n";

$class = new MyClass();
$class-&gt;showConstant();

echo $class::constant."\n";
?&gt;
</pre>
<hr>

<h3>Sınıf Soyutlaması (Class Abstraction)</h3>

PHP 5 soyut sınıf ve yöntemleri sunar. Soyut tanımlanmış bir sınıfın kopyasını yaratmaya izin verilmez. Herhangi bir sınıf en az bir soyut yöntem içerirse, kendisi de soyut olmalıdır. Bir yöntemin soyut olması için imzasının tanımlanması gerekir.
<br /><br />
Bir soyut sınıfın kalıtını kullanırken, babanın sınıfdaki tüm soyut yöntemler çocuk tarafından da tanımlanabilmelidir. Ek olrak bu yöntemler aynı görünürlükte olmalıdır. Örneğin eğer bir soyut yöntem korunmalı tanımlanmışsa, işlev uyarlaması da korunmalı y ada halka açık olmalı ama özel olmamalıdır.
<br /><br />
Soyut sınıf örneği
<pre>
&lt;?php
abstract class AbstractClass
{
    // sınıfı genişletip bu yöntemi tanımlaması zorlanır
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // Genel yöntem
    public function printOut() {
        print $this-&gt;getValue() . "\n";
    }
}

class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

class ConcreteClass2 extends AbstractClass
{
    public function getValue() {
        return "ConcreteClass2";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass2";
    }
}

$class1 = new ConcreteClass1;
$class1-&gt;printOut();
echo $class1-&gt;prefixValue('FOO_') ."\n";

$class2 = new ConcreteClass2;
$class2-&gt;printOut();
echo $class2-&gt;prefixValue('FOO_') ."\n";
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
ConcreteClass1
FOO_ConcreteClass1
ConcreteClass2
FOO_ConcreteClass2
</pre>
   
içinde kullanıcı tanımlı sınıflar ve "abstract" işlevler  eski kodlama değiştirilmeden kullanılabilir.
<hr>

<h3>Nesne Arayüzü (Object Interfaces)</h3>

Nesne arayüzü yaratılacak kodlamada bir sınıfın hangi yöntemlerinin uygulanacağının iznini verir. Bu yöntemlerin nasıl ele alınacağını tanımlamak gerekmez.
<br /><br />
Arayüzler "interface" anahtar kelimesiyle sıradan bir sınıf gibi tanımlanır ama yöntemlerin hiçbirinde içerik tanımlı değildir.
<br /><br />
Arayüz altında tanımlanan  yöntemlerin hepsi halka açık olmalıdır. Bu arayüzün doğasıdır.<br />
<b>uygulanması (implements)</b>
<br /><br />
Bir arayüzün uygulanması için "implements" işlemi kullanılır. Bir arayüz içindeki tüm yöntemler bir sınıf ile uygulanır. Bunun yapılmasından oluşan hata kritik hatadır. Sınıflar birden çok arayüzün uygulanmasını her arayüzün arasında kullanılan virgülle sağlar.
<br /><br />
    Not: Bir sınıf aynı işlev adlarını paylaşan iki arayüzün uygulanmasını sağlayamaz. Karmaşa olur.
<br /><br />
<b>Örnekler (Examples)</b>
<br /><br />
Arayüz örneği
<pre>
&lt;?php
// 'iTemplate' arayüzünü tanımlama
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}

// Arayüzün uygulanması (Implement)
// Bu çalışır
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this-&gt;vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this-&gt;vars as $name =&gt; $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// Bu çalışmaz
// Kritik Hata: BadTemplate sınıfının 1 soyut yöntemi var
// ve bu nednele soyut tanımlanmalıdır (iTemplate::getHtml)
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this-&gt;vars[$name] = $var;
    }
}

?&gt;
</pre>
"instanceoff" işlemine de bakın.
<hr>

<h3>Aşırı Yükleme (Overloading)</h3>

Yöntem çağırmaları ve üye erişimleri __call, __get ve __set yöntemleriyle aşırı yüklenebilir. Bu yöntemlerin tetiklenmesi ancak nesne ya da nesne kalıtı erişilecek bir üye ya da yöntem bulunmadığında olmalıdır. Tüm aşırı yükleme yöntemleri halak açık tanımlanmalıdır ve durağan olmamalıdır.
<br /><br />
PHP 5.1.0 sürümünden beri isset() ve unset() işlevlerini __isset ve __unset yöntemleriyle aşırı yükleme yapma olanağı vardır. __isset yöntemi empty() ile çağrılır.
<b>Üye aşırı yüklenmesi (Member overloading)</b>
<pre>
void __set ( string $name , mixed $value )
mixed __get ( string $name )
bool __isset ( string $name )
void __unset ( string $name )
</pre>
<br />
Sınıf üyeleri sizin sınıfın içindeki özel adlı yöntemleri tanımlarken kullanıcı kodlamasını çalıştırılmasında aşırı yüklenebilir. $name parametresi kurulacak ya da okunacak değişkenin adını içerir. __set() yönteminin $value parametresi o nesnenin $name değerini neye atıyacağını gösterir.
<br /><br />
    Not: __set() yöntemi parametreleri adres biçiminde olamaz.
<br /><br />
__get, __set, __isset ve __unset ile aşırı yüklenme örneği
<pre>
&lt;?php
class Setter
{
    public $n;
    private $x = array("a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3);

    public function __get($nm)
    {
        echo "Alınan [$nm]\n";

        if (isset($this-&gt;x[$nm])) {
            $r = $this-&gt;x[$nm];
            print "Dönen: $r\n";
            return $r;
        } else {
            echo "Hiçbir şey!\n";
        }
    }

    public function __set($nm, $val)
    {
        echo "Kurulan [$nm] to $val\n";

        if (isset($this-&gt;x[$nm])) {
            $this-&gt;x[$nm] = $val;
            echo "OK!\n";
        } else {
            echo "OK değil!\n";
        }
    }

    public function __isset($nm)
    {
        echo "$nm kuruldu mu kontrolu\n";

        return isset($this-&gt;x[$nm]);
    }

    public function __unset($nm)
    {
        echo "$nm silinmesi\n";

        unset($this-&gt;x[$nm]);
    }
}

$foo = new Setter();
$foo-&gt;n = 1;
$foo-&gt;a = 100;
$foo-&gt;a++;
$foo-&gt;z++;

var_dump(isset($foo-&gt;a)); //true
unset($foo-&gt;a);
var_dump(isset($foo-&gt;a)); //false

// __isset() yöntemine geçirilmez
// çünkü 'n' halka açık bir özelliktir
var_dump(isset($foo-&gt;n));

var_dump($foo);
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
Kurulan [a] to 100
OK!
Alınan [a]
Dönen: 100
Kurulan [a] to 101
OK!
Alınan [z]
Nothing!
Kurulan [z] to 1
Not OK!

a kuruldu mu kontrolu
bool(true)
a silinmesi
a kuruldu mu kontrolu
bool(false)
bool(true)

object(Setter)#1 (2) {
  ["n"]=>
  int(1)
  ["x":"Setter":private]=>
  array(2) {
    ["b"]=>
    int(2)
    ["c"]=>
    int(3)
  }
}
</pre>

    

<b>Yöntem aşırı yüklenmesi (Method overloading)</b>
<pre>
mixed __call ( string $name , array $arguments )
</pre>
Tılsımlı yöntem __call() olmayan yöntemlerin çağrılmasının yakalanmasına izin verir. __call() kullanım biçimi kullanıcı tanımlı yöntemlerin ele alınmasında uyarlanın kullanılmasına yarar. Bu da asıl yöntemin adına bağlıdır. Bu örneğin "proxy" uygulaması için yararlıdır. İşleve geçirilen parametreler $arguments parametresinde bir dizi olarak tanımlanabilir. __call() yönteminden dönen değer bu yöntemi çağırana döner.
<br /><br />
__call örneğiyle aşırı yükleme
<pre>
&lt;?php
class Caller
{
    private $x = array(1, 2, 3);

    public function __call($m, $a)
    {
        print "Method $m called:\n";
        var_dump($a);
        return $this-&gt;x;
    }
}

$foo = new Caller();
$a = $foo-&gt;test(1, "2", 3.4, true);
var_dump($a);
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
Method test called:
array(4) {
    [0]=>
    int(1)
    [1]=>
    string(1) "2"
    [2]=>
    float(3.4)
    [3]=>
    bool(true)
}
array(3) {
    [0]=>
    int(1)
    [1]=>
    int(2)
    [2]=>
    int(3)
}
</pre>
<hr>
    
<h3>Nesne Döngüleri (Object Iteration)</h3>

PHP 5 nesnelerin tanımlanması için bir yol sunar. Böylece onları bir listede 'foreach' gibi işlemlerle döndürme olanağı doğar. Varsayılan olarak döngülerde tüm görünürlük parametreleri kullanılır.
<br /><br />
Basit nesne döngüsü örneği
<pre>
&lt;?php
class MyClass
{
    public $var1 = 'değer 1';
    public $var2 = 'değer 2';
    public $var3 = 'değer 3';

    protected $protected = 'protected var';
    private   $private   = 'private var';

    function iterateVisible() {
       echo "MyClass::iterateVisible:\n";
       foreach($this as $key =&gt; $value) {
           print "$key =&gt; $value\n";
       }
    }
}

$class = new MyClass();

foreach($class as $key =&gt; $value) {
    print "$key =&gt; $value\n";
}
echo "\n";


$class-&gt;iterateVisible();

?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
var1 =&gt; değer 1
var2 =&gt; değer 2
var3 =&gt; değer 3

MyClass::iterateVisible:
var1 =&gt; değer 1
var2 =&gt; değer 2
var3 =&gt; değer 3
protected =&gt; protected var
private =&gt; private var
</pre>

   

Yukarıdaki örneğin gösterdiği gibi, 'foreach' görünür değişkenlerden erişilebilenlerin döngüsünü oluşturur. Bunu bir adım daha ileri götürmek için, PHP 5 içindeki 'iterator' arayüzünü uygulayabilirsiniz. Bu nesnenin ne ve nasıl yineleneceğini belirtir.
<br /><br />
Nesne yinelemesinda 'Iterator' uygulaması örneği
<pre>
&lt;?php
class MyIterator implements Iterator
{
    private $var = array();

    public function __construct($array)
    {
        if (is_array($array)) {
            $this-&gt;var = $array;
        }
    }

    public function rewind() {
        echo "geri sar\n";
        reset($this-&gt;var);
    }

    public function current() {
        $var = current($this-&gt;var);
        echo "o an: $var\n";
        return $var;
    }

    public function key() {
        $var = key($this-&gt;var);
        echo "anahtar: $var\n";
        return $var;
    }

    public function next() {
        $var = next($this-&gt;var);
        echo "sonraki: $var\n";
        return $var;
    }

    public function valid() {
        $var = $this-&gt;current() !== false;
        echo "geçerli: {$var}\n";
        return $var;
    }
}

$values = array(1,2,3);
$it = new MyIterator($values);

foreach ($it as $a =&gt; $b) {
    print "$a: $b\n";
}
?&gt;
</pre>
Yukarıdaki örneği çıktısı:
<pre>
geri sar
o an: 1
geçerli: 1
o an: 1
anahtar: 0
0: 1
sonraki: 2
o an: 2
geçerli: 1
o an: 2
key: 1
1: 2
next: 3
o an: 3
geçerli: 1
current: 3
anahtar: 2
2: 3
geçerli:
o an:
geçerli:
</pre>

Siz kendi sınıfınızı da tanımlayabilirsiniz. Böylece tüm 'Iterator' işlevlerini yalnız PHP 5 IteratorAggregate arayüzünü uygulayarak kullanmanız gerekmemiş olur.
<br /><br />
IteratorAggragte ile nesne döngüsü uygulaması örneği
<pre>
&lt;?php
class MyCollection implements IteratorAggregate
{
    private $items = array();
    private $count = 0;

    // IteratorAggregate arayüzü için gereken 
    public function getIterator() {
        return new MyIterator($this-&gt;items);
    }

    public function add($value) {
        $this-&gt;items[$this-&gt;count++] = $value;
    }
}

$coll = new MyCollection();
$coll-&gt;add('değer 1');
$coll-&gt;add('değer 2');
$coll-&gt;add('değer 3');

foreach ($coll as $key =&gt; $val) {
    echo "anahtar/değer: [$key -&gt; $val]\n\n";
}
?&gt;
</pre>
Yukarıdaki örneğin çıktısı:
<pre>
geri sar
o an: değer 1
geçerli: 1
o an: değer 1
anahtar: 0
key/value: [0 -&gt; değer 1]

sonraki: değer 2
o an: değer 2
geçerli: 1
o an: değer 2
anahtar: 1
anahtar/değer: [1 -&gt; değer 2]

sonraki: değer 3
o an: değer 3
geçerli: 1
o an: değer 3
anahtar: 2
anahtar/değer: [2 -&gt; değer 3]

sonraki:
o an:
geçerli:
</pre>

    Not: Yineleme ve döngüler için SPL Uzantısına da bakın

<hr>
<a href="php5txt391.html" class="ynav">Sınıflar ve Nesneler (PHP 5) Bölüm 2</a>    
<br />
</div>
         </div>
         <span><img src="img/notebook1.gif"><br /></span>
       </div>
    </td><td valign="top">
       <div id="sagtaraf">
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x600, created 1/16/08
google_ad_slot = "7007060807";
google_ad_width = 120;
google_ad_height = 600;
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<script type="text/javascript"><!--
google_ad_client = "pub-8541306787668208";
//120x240, created 1/25/08
google_ad_slot = "8433790203";
google_ad_width = 120;
google_ad_height = 240;
google_cpa_choice = ""; // on file
//--></script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
       </div>
    </td></tr>
    </table>
</div>
</body>
</html>
