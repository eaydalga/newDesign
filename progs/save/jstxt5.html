<html>
<body>
<div id="sag"><span class="yazi">3 Aralık 2007</span></div>
<div class="yazi">
<h2>Değişkenler</h2>
Javascript için değişkenlerin önemi yoktur. Gerek oldukça değiştirilebilirler. Bunun anlamı bir anda değişken yazı dizisi saklıyorsa, diğer anda tam sayı içerebilir. Temel değişken tipleri şunlardır:
<dl>
<dt>character</dt>
    <dd>'a' ya da '@' ya da 'k' vb.
<dt>string</dt>
    <dd>'hdttgs 8 -46hs () Düşünceyi anlayın'
<dt>integer</dt>
    <dd>0 ya da 1 ya da 2 ya da 3 ya da 4 vb. ya da -1 ya da -2 ya da -3 ya da -4 vb.
<dt>float (or double)</dt>
    <dd>23.546 ya da -10.46
<dt>boolean</dt>
    <dd>doğru (true) ya da yanlış (false)
<dt>function</dt>
    <dd>Bir işlev (function) işlevler bölümüne bakmayı unutmayın
<dt>object</dt>
    <dd>Bir nesne (object); Nesnel programlama bölümüne bakın
<dt>array</dt>
    <dd>Değişkenleri hücrelerde saklayabilen bir tür nesnedir
<dt>undefined</dt>
    <dd>Henüz bir değeri olmayan değişken
<dt>null</dt>
    <dd>Tanımlanmış ama null değeri atanmış bir değişken
</dl>
Tamsayılar ve kayan noktalılar 'number' (sayı) olarak sınıflandırılmıştır. Karakter ve yazı dizisi 'string' (yazı dizisi) olarak adlandırılır.

Bir değişkenin hangi tür olduğunu bulan 'typeof' işlemi. Not: "typeof" diziler ve "null" için 'object' (nesne) değeri döndürür.

<h3>Değişkenleri tanımlama</h3>
Erişim adı bölüme ve erişim çelişkileri adlı alt bölüme bakınız.

<h3>Normal Değişkenler</h3>

Kullanılan değişkenleri önceden "var" anahtar kelimesiyle tanımlamak güzel bir alışkanlıktır. Bir değişkeni tanımlamak ve değerini tanımlamamak ya da hemen bir değer atamak ya da birden çok değişkeni tek satırda tanımlamak olanağı vardır:

<fieldset class="fyazi">
<pre>
var variablename;
var variablename = value;
var vari1 = value, vari2 = anotherValue, vari3;
</pre>
</fieldset>

javascript oldukça hoşgörülüdür ve siz 'var' anahtar kelimesiyle tanımlamamışsanız, kendisi evrensel değişkenler yaratır. Eğer tanımlanmamış bir değişkene değer atarsanız bu işlem doğrudur ama içinde bir değer varmış gibi okunmaya kalkılırsa hata mesajı ortaya çıkar. Ayrıca bu bir başka soruna da neden olabilir. Kazayla  başka ortamlardaki değişkenin değerini ezmek bile söz konusu olabilir.
Bir kez değişken tanımlandı mı bir daha 'var degisken_adi' biçimini bir daha kullanmayın (eğer o değişkeni tümüyle ezmek istiyorsanız kullanabilirsiniz). Aynı ortamda "var" anahtar kelimesiyle aynı değişkeni birden çok tanımlamaya gerek yoktur. Ama tarayıcı sorun çıkartmaz, yapsanız da kabul eder.

Aşağıdakiler değişkenleri tanımlamak için kullanılan örneklerdir. Burada bir yazı dizisi, bir sayı ve bir deyim tanımlanmıştır:

<fieldset class="fyazi">
<pre>
var myFish = 'A fish swam in the river';
var myNumberOfGoats = 23;
var myPattern = /<[^>]*@[^<]*>/gi;
</pre>
</fieldset>

<h3>Nesneler (Objects)</h3>

    <li> WebTV 2.6- Nesne yaratırken {} yazım kuralını desteklemez.</li>

Bir değişkenin çocuklarının özellikleri olması gerekiyorsa bu değişkeni bir nesne olarak tanımlamak gerekir. Bir değişkeni nesne olarak tanımlamak için ya
new Object() ya da {} yazım kuralını kullanın:
<br />
<br />
<fieldset class="fyazi">
<pre>
var variableName = new Object();
var variableName = {myFirstProperty:1,myNextProperty:'hi',etc};
</pre>
</fieldset>
İstediğiniz nesnelere çocuk nesneler ya da özellikler atayabilirsiniz.

<fieldset class="fyazi">
<pre>
variableName.aPropertyNameIMadeUp = 'hello';
variableName.aChildObjectNameIMadeUp = new Object();
</pre>
</fieldset>

Yeni yarattığınız bir nesne üzerinde bir yöntem çalıştırmak isterseniz, gerçek Javascript 1.2 ortamında nesneyi kıvrımlı parantezler arasına almanız gerekir (ilk Netscape 4'lerde sorun çıkar). Bu tanım NN 4 zamanındaki tarayıcılarda da çalışmaz.
<pre>
new Date().getTime()
</pre>

Bu örnek Javascript destekleyen tüm tarayıcılarda çalışır:
<pre>
( new Date() ).getTime()
</pre>
Bu tanım tüm nesnelere (Array, Image, Option, Object, Date ve sizin yarattıklarınız) uyarlıdır.
<h3>Diziler</h3>

    <li> WebTV 2.6- Dizi yaratırken [] dil kuralını desteklemez.</li>

Diziler, yukarıda tanımlanan nesnelere benzer. Ama birkaç küçük ayrıntıda farklılık gösterir. Bir dizi kutu gibi düşünülse, içinde bölümler vardır ve sayılarını değiştirme olanağı bulunur. Her bölümün içeriğine erişmek için kutunun adını, köşeli parentezler içine de bölümün adı ya da sıra numarası yazılır. Bir dizi yaratırken new Array() ya da [] dil kuralı kullanılır:
<fieldset class="fyazi">
<pre>
var nameOfArray = new Array();
var nameOfArray = new Array('content_of_first_cell','and_the_second',8,'blah','etc');
var nameOfArray = ['content_of_first_cell','and_the_second',8,'blah','etc'];
</pre>
</fieldset>
Dizi nesneleri yaratırken bir sayı parametre olarak kullanılabilir. Eğer sayı pozitif bir sayıyısa, dizi belirtilen sayıda hücreyle yaratılır. Hücrelerin hepsi boştur.
<pre>
new Array(5)
</pre>
Eğer dil niteliğini Javascript 1.2 yazarsanız, bu tanımla bazı tarayıcılar (hepsi değil) bir hücreli bir dizi yaratır ve ilk değeri 5 olur.
<br /><br />
Bir dizinin hücrelerinin içeriğine erişmek için "dizi_adi[hücre_sıra_no ya da hücre_adi] (sıra no yerine ad kullanıyorsanız ad tırnak içinde yazılmalıdır). Sayısal hücre tanımları sıfırdan başlar, bazı programlama dillerindeki gibi birden değil.
<br /><br />
Javascript için dizi ve nesne hemen hemen aynı şeydir ve dizinin adlandırılmış bir hücresine erişim, bir nesnenin özelliğine erişimle aynıdır. Eğer bir dizinin hücresi "mycell" diye adlandırılırsa, aşağıdakilerden birini kullanarak içeriğine erişebilirsiniz:
<pre>
nameOfArray['mycell']
nameOfArray.mycell
</pre>

Dizilerle nesneler arasında önemli bir fark vardır. Varsayılan olarak dizilere birçok yöntem eklenmiştir. Dizi içinde gezinmekte kullanılan ya da diziyi parçalara ayıran. Buna ek olarak eğer sayılar kullanılırsa, dizide kaç tane hücre olduğu dizi_adi.length kullanılarak öğrenilebilir.
<br /><br />
Çok boyutlu diziler üretilebilir. Bir dizi öğesi bir başka dizi olarak tanımlanırsa çok boyutlu dizi tanımı yapılmış olur. Örneğin:
<pre>
var nameOfArray = new Array(new Array(1,2,3,4),'hello',['a','b','c']);
</pre>
Bu tür dizi hücrelerine erişin köşeli parantezleri iki kez kullanılarak sağlanılır (ya da boyut sayısına bağımlı olarak çok kez):
<Pre>
nameOfArray[name_or_number_of_entry][name_or_number_of_inner_entry]
</pre>
<h3>Diğer nesne türleri</h3>

Tarayıcıların birçok hazır nesnesi vardır. Tüm Javascript yetenekli tarayıcılar aşağıdaki nesneleri destekler:
<dl>
<dt>Date</dt>
    <dd>Tarih nesnesini yaratır. Tarih üzerine işlem yapılmasını sağlar. Örneğin:
<pre>
    var mydate = new Date();
    window.alert( 'The year is' + mydate.getFullYear() );
</pre>
    </dd>

<dt>Image</dt>
    <dd>
    Görünmeyen ama bellekte saklanan bir resim yaratır. "src" niteliğine atama yaparak tarayıcı belleğine yükleme yapılması sağlanır:
<pre>
    var myimage = new Image();
    myimage.src = 'thing.gif';
</pre>
    Sayfadaki resmin değiştirilmesi istendiğinde, document['resimadi'].src = myimage.src; yazılarak resmin değişmesi sağlanır. Resim daha önce yüklenmiş olduğundan resmin değişmesi hemen olur.
    </dd>
<dt>Option</dt>
    <dd>
    Seçimli giriş alanı için yeni bir seçenek eklenmesini sağlar. Örneğin:
<pre>
    var myoption = new Option('text','value');
    selectInput.options[selectInput.options.length] = myoption;
</pre>
    </dd>
</dl>
Nesnelerin yaratılması bölümüne bakarak kendi nesnelerinizi nasıl yaratacağınızı öğrenebilirsiniz. DOM destekleyen tarayıcılar daha çok nesne türleri sunarlar.

<h3>Özellikleri Silme</h3>

Bu sayfada nesneler için değişik zamanlarda özellikler yaratılmıştır. 
Yaratılanlar "undefined" (tanımsız) ya da "null" (boş) olsalar bile var oldukları için yer alırlar. Bunların hepsini "delete" anahtar sözcüğüyle silebilirsiniz.
<pre>
delete myObject.itsProperty;
</pre>
Ciddi bilgisayar bellek sorununuz yoksa ya da güvenlik riskleri oluşmuyorsa bu işlemi yapmanın genelde bir gereği yoktur. Javascript yorumlayıcılar hiç kullanılmayan değişkenleri temizlerler.

<h3>Değişkenlerle hataları giderme</h3>

herhangi bir anda, olmayan bir değişkene erişmek isterseniz hemen hata alırsınız. Ama Javascript nesnelerin ilk düzey çocuklarına olmasalar bile erişmenize izin verir. Bu öğrenilmesi gereken çok önemli bir kuraldır ve tarayıcılara bağımlı olmadan çalışabilen kodlar yazılmasını sağlar. Aşağıdaki örnekler nelerin hataya dönüştüğünü gösterir:
<pre>
var myObject = new Object(), nonObject = '', nonObject2;
</pre>
Aşağıdaki örnek için atamalar yapılmıştır. Buraya değin herşey normaldir. Aşağıdaki kodda b tanımlanmamış olduğu için hata verir:
<pre>
var a = b + 5;
</pre>
Aşağıdaki örnekte üst düzey nesne tanımlı ama çocuğu tanımlı değildir. Bu tek düzeylik tanımsız özelliklik olduğundan hata vermez ve kabul edilir.
<pre>
var b = myObject.myChild;
</pre>
Aşağıdaki örnekte üst düzey nesne tanımlıdır ama özelliği tanımlanmamıştır. Tanımlanmamış özelliğin çocuğuna erişmeye kalkmak iki düzeyli tanımsızlığı kullanmak olduğundan hata oluşmasına neden olur:
<pre>
b = myObject.myChild.itsChild;
</pre>
Aşağıdaki örnekte üst düzey nesne tanımlıdır. Ama bu değişken çocuk özelliklerini kabul edemez. Buraya çocuk eklemeye çalışmak hata oluşturmaz, çünkü tanımsızlığın ilk düzeyidir. Ama hiçbir şey yapmaz çünkü özellik red edilmiştir.
<pre>
nonObject.itsChild = 7;
window.alert(nonObject.itsChild);
//Bunun sonucunda 'undefined' görüntülenir
</pre>
Aşağıdaki örnekte, üst düzey nesne tanımlıdır ama ona değer verilmemiştir. Sonuç olarak değeri "undefined" olur. Çoçuk özelliklere erişmeye kalkmak ikinci düzey tanımsızlığa yol açacağından hata oluşur:
<pre>
nonObject2.itsChild = 7;
</pre>
<h3>Bir değişkene erişim ya da değerini alma</h3>

Bir değişkeni diğerine atadığınızda, bazı koşullarda birinin değerinin diğerine yapıştırıldığı durumlar vardır. Ama bazı koşullarda değişkenin değeri yerine bu değişken için yeni bir erişim yöntemi oluşturulmuş olunur. Örneğin:
<pre>
var myNewVariable = myOldVariable;
</pre>
Eğer myoldVariable bir yazı, sayı, mantıksal değer, null ya da undefined olarak tanımlanmışsa, budara içeriği kopyalanıp mynewVariable değişkenine taşınmış olur. Eğer yeni değişkenin değeri değişirse (mynewVariable='bir başka değer';) myoldVariable eskisi gibi kalır.

Diğer taraftan eğer myoldVariable daha önce bir işlev, dizi, nesne ya da seçenek olarak tanımlanmışsa, mynewVariable myoldVariable'a gösterge olarak yaratılır. myoldVariable çocukları mynewVariable çocukları olur. Eğer yeni değişkenlerin değeri değişirse (örneğin mynewVariable = 'bir değer'; gibi), bu yalnız mynewVariable değerini etkiler. Artık myoldVariable göstergesi değildir. Ama mynewVariable özelliklerini değiştirmek, gösterdiği değişkenin özelliklerini değiştirmekle aynı şeydir.
<pre>
var myOldVariable = new Object();
var myNewVariable = myOldVariable;
myNewVariable.newChild = 'Hello';
alert(myOldVariable.newChild);
//Burada 'Hello' görüntülenir
</pre>

<h3>Sayılar Üzerine</h3>

Javascript birçok kalıpta sayıalrı anlar. Böylece sayıları hex, ondalık ve sekizlik tanımlamak olanağı vardır. Eğer bir sayının solunda 0 varsa ve içinde yediden büyük sayı yoksa bu değer sekizli sayı anlamına gelir. Eğer sayının önünde 0x varsa sayı hex kabul edilir (o zaman A B C D E F) değerleri de tanımlanabilir. Bunların hiç birinde kayan nokta olmaz.

Ondalık sayılarda 12e+4 12x10 üzeri 4 yerine, 12e-4 12x10 üzeri -4 yerine kullanılabilir.

Bir kaç değişik sayı gösterilimi daha vardır. Bunlarla Math nesnesi içinde karşılaşırız. Bunları değişken gibi kullanabiliriz ama değer ataması yapamayız.

Var olan Math nesnesi değişmezleri:
<table class="yazi" cellspacing="2" cellpadding="0" border="1">
<tr><th colspan="3">Math nesnesi değişmezleri</th></tr>
<tr><th>Math nesne özelliği</th><th>Değer (yaklaşık)</th><th>Matematiksel karşılığı</th></tr>
<tr><td>Math.E</td><td>2.718</td><td>e</td></tr>
<tr><td>Math.LN2</td><td>0.693</td><td>ln(2)</td></tr>
<tr><td>Math.LN10</td><td>2.303</td><td>ln(10)</td></tr>
<tr><td>Math.LOG2E</td><td>1.442</td><td>log2(e)</td></tr>
<tr><td>Math.LOG10E</td><td>0.434</td><td>log10(e)</td></tr>
<tr><td>Math.PI</td><td>3.142</td><td>Pi</td></tr>
<tr><td>Math.SQRT1_2</td><td>0.707</td><td>(sqrt(2))-1 or sqrt(1/2)</td></tr>
<tr><td>Math.SQRT2</td><td>1.414</td><td>sqrt(2)</td></tr>
</table>

<h3>Özel yazı dizisi karakterleri</h3>

Birkaç tane karakter vardır. Ters kesmeyle kullanılır ve görünmeyen karakterleri gösterir:
<dl>
<dt>\n</dt>
    <dd>
    Yeni satır karakteri. Yazının içinde yeni satır gerektiğinde kullanılır.
    </dd>
<dt>\f</dt>
    <dd>
    Bunu hiç kullanmamaya çalışın her zaman yerine \n kullanın.
    </dd>
<dt>\r</dt>
    <dd>
    Taşıyıcı geriye. Hiç kullanmamaya çalışın yerine \n kullanın.
    </dd>
<dt>\t</dt>
    <dd>
    Tab karakteri.
    </dd>
<dt>\\</dt>
    <dd>
    \ karakteri
    </dd>
<dt>\/</dt>
    <dd>
    / karakter (birçok web tasarımcısı bunu unutur. Tarayıcıların unuttulan ters kesme konusunda bir sorunları olmaz
Tarayıcılara biçimin kapandığını belirtmek için kullanılır ve teoride düz kesmeyi her zaman ters kesmeyle birlikte kullanılması gerekir.
    </dd>
</dl>
Eğer windows satır kırılmasını aramak isterseniz \r\n aramalısınız. Eğer satır kırılımı eklemek isterseniz (örneğin textarea giriş alanını değiştirecekseniz) araya \n eklemelisiniz. Bu yöntem tarayıcılar arasında çalışır. Windows üzerindeki tarayıcılar \n değerini gerek olduğunda \r\n biçimine çevirir.

Eski Mac işletim sistemi (OS 9 ve aşağısı) satır kırılımları için \r kullanır. Ama Javascript bunları \n değerine çevirmektedir. Özellikle bilgi girişlerinde yazı dizileri içinde karşılaşabilirsiniz.

Eğer bir yazı dizisi kullanıyorsanız ve içinde çift tırnak varsa bunu çözmenin en basit yolu doşta kullanılan tırnakları tek tırnak olarak belirlemektir. Tersi de geçerlidir: Eğer yazı dizisi içinde tek tırnak varsa çift tırnağı dışta kullanmalısınız.
<pre>
var mystring = 'And he said "help" twice';
var mystring = "Help Andy's cat";
</pre>
Burada bir sorun var. Eğer yazı dizisinde hem tek hem de çift tırnak kullanılıyorsa ne yapılmalıdır? Çözüm '\' kullanarak tırnağın niteliğini değiştirmektir. Örneğin:
<pre>
var mystring = 'And he said "help Andy\'s cat" twice';
var mystring = "And he said \"help Andy's cat\" twice";
</pre>
Eğer yazı dizisi çok uzun olup bir satıra sığmazsa (bu çok önemli değildir siz yazıyı istediğiniz kadar uzun yapabilirsiniz), onu birkaç satıra bölersiniz. basit olarak yazı dizisini tırnakla kapatın ve sonra ekleme işlemiyle (+ işareti) yazı dizisinin kalanlarını yazın.
<pre>
var mystring = 'first line of the string ' +
    'still on the first line of the string - it\'s like we never' +
    'broke the line';
</pre>
Teorik olarak bir yazı dizisini parçalarken \ da kullanabilirsiniz.
<pre>
var mystring = 'like \
  this';
</pre>
Bu aslında çok sorun çıkarabilir. \ her zaman bir boşlukla kullanılmalıdır. Satır sonuna gelen boşluk yorumlanamayabilir.

    <li> Netscape 4 (JavaScript kodunu bulanlar), Escape, Opera ve ICEbrowser satır kırılımlarını yazı dizisi içinde ister.</li>
    <li> Internet Explorer, Mozilla/FireFox, iCab ve OmniWeb satır kırılım karakterini yok sayar.</li>
    <li> ICEbrowser yazı dizisini bazen tümüyle siler</li>

Bunları kullanmak yerine her zaman daha kolay olan birleştirme işlemini kullanmakta yarar vardır.
<h3>Kurallı Deyim (Regular expression)</h3>

    <li> Opera 4-6 hatalıdır. En basit deyimi bile çözememektedir</li>
    <li> Cep Internet Explorer, Windows CE için Internet Explorer ve iCab 2- düzgün desteklememektedir</li>

Bazı yöntemler stringObject.replace() ve stringObject.match() gibileri yazı içinde verilen deseni bulabilmektedir. Bunu kullanabilmek için kurallı deyim (regular expression) yazılmalıdır.
Temelde yapılacak olan özel karakterler kullanarak desen (patern) oluşturmaktır. Bu tür karakter toplamına kurallı deyim (regular expression) denir. Örneğin:
<pre>
 /\/\*[\w\W]*\*\//
</pre>
yazıdaki blok açıklamaları bulur.

Ender kullanılan tarayıcıların bazıları kurallı deyim (regular expression) desteklemez. Teorik olarak aşağıdakini yazdığınızda tarayıcının kurallı deyim destekleyip desteklemedi anlaşılır:
<pre>
if( window.RegExp ) { var myRegularExpression = new RegExp("pattern"); }
</pre>
Bu windows CE için IE'de ve Cep IE'de hata oluşturmaz. Ama Opera 6- ve iCab 2- RegExp destekler ama doğru kullanamaz. Bu nedenle kodlamanız çalışmayacaktır. Yeni Opera ve iCab sürümlerinde RegExp doğru çalışmaktadır.
</div>
<br />
</body>
</html>
