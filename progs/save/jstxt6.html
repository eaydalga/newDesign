<html>
<body>
<div id="sag"><span class="yazi">3 Aralık 2007</span></div>
<h2>Denetim Yapıları</h2>
<div class="yazi">
<h3>if deyimi</h3>
<pre class="yazi">
if( myVariable == 2 ) {
  myVariable = 1;
} else {
  myVariable = 0;
}
</pre>
Eğer myvariable 2 olsaydı, işlemden sonra 1 olurdu. Eğer 2'den başka birşey olsaydı işlem sonrası değeri 0 olurdu.
<br />
<br />
Eğer deyimi bir nesnenin olmayan çocuk nesnesinin varlığını da test edebilir.
Örneğin bazı tarayıcılar document.body.style nesnesini sunarken eski tarayıcılar document.body nesnesini sunmaz bile. Bunlarda document.body.style hata verir. Bu sorunu çözmek için:
<br />
<pre class="yazi">
if( document.body ) {
  if( document.body.style ) { etc. }
}
</pre>
<br />
Burada &amp;&amp; işlemini kullanarak daha kullanışlı bir if deyimi yapılabilir:
<pre>
if( document.body && document.body.style ) { etc. }
</pre>
<br />
Eğer ilk karşılaştırma yanlışsa ikinciye devam edilmez. Buna kısa devre de denir. Aynı biçimde || işlemi de kullanılabilir. Ama bu işlemde ikinci koşul birincisi yanlış olursa irdelenir.

<br />
<br />
Eğer kıvrımlı parantezler olmazsa if deyiminden sonraki yalnız bir deyim if deyiminin parçası olur.
<br />
<pre>
if( x < 5 )
x++;
window.alert(x);
</pre>
<br />
Bu örnekte "alert" x değerine bakmaksızın oluşur ama x değeri ancak 5'den küçükse bir arttırılır.
Bu kullanılır bir özellik gibi gözükebilir. Çünkü kodlamanızı biraz daha küçültmüş olursunuz ama önerilen bu yazım kurallını hiç kullanmamanızdır. Eğer denetim yapılarını iç içe kullanmaya başlarsanız, kodlamanızın okunması çok güçleşir. Her zaman kıvrımlı parantez kullanmak (seçenek olsa bile) daha iyidir.
<br />
<br />

Aşağıdaki gibi iç içe tanımlanmış if deyimlerinde yönetim güçleşmeye başlar:
<br />
<pre>
if( myVariable == 2 ) {
  myVariable = 1;
} else {
  if( myVariable == 5 ) {
    myVariable = 3;
  } else {
    myVariable = 4;
  }
}
</pre>
<br />
Başka programlama dillerinde olduğu gibi kıvrımlı paranntezler kullanışlı bir biçimde kaldırılabilir. Burada "elseif" değil "else if" kullanıldığına dikkat edin.
<br />
<pre>
if( myVariable == 2 ) {
  myVariable = 1;
} else if( myVariable == 5 ) {
  myVariable = 3;
} else {
  myVariable = 4;
}
</pre>
<h3>'for' Döngüsü</h3>

<br />
En sık kullanılan yapılardan biridir. Bir dizinin içeriğinde gezinirken kullanılır (tipik kullanım biçimlerinden biridir). Ya da belirli sayıda nesne yaratırmak önemli olur. 'for' döngüsünün yazım kuralı şöyledir.
<br />
<pre>
for( ilk_değer; gidebildiğin_kadar_koşulu; her_zaman_yap )
<br />
</pre>
<dl>
<dt>ilk_değer</dt>
    <dd>
    Döngü içinde kullanacağınız yeni değişkenleri tanımladığınız yerdir. Özellikle arttırılan sayaçlar burada tanımlanır. Her değişkende olduğu gibi bu değişkenlerinde tanımı yapılmalıdır. Birden çok değişkeni aşağıdaki gibi tanımlamak olanağı vardır (eğer gerek varsa):
<pre>
    var degisken1 = deger, degisken2 = baska_deger;
</pre>
    Bu değişkenler 'for' döngüsü içinde kalmakla sınırlı değildirler. Döngüyle aynı kapsam içinde olan tüm kodlamada kullanılabilirler.
    </dd>
<dt>gidebildiğin_kadar_koşulu</dt>
    <dd>
    This is where you define the conditons under which the loop should continue to execute. The syntac is exactly the same as for the 'if' statement, so you can apply more than one continue condition by using the && or || operators:
    Hangi koşulda döngü deyimlerinin çalıştırılacağının belirtildiği yerdir. Döngüye devam etme koşulu burada belirtilir. Koşulda && ya da || kullanılabilir.
<pre>
    degisken1 <= 5 && degisken2 >= 70;
</pre>
    Eğer koşul sağlanmazsa kodlama döngüye hiç girmez.
    </dd>
<dt>her_zaman_yap</dt>
    <dd>
    Bir kez döngünün sonuna gelinince, burada ne yapılacağı belirtilir. Tipik olarak döngü değişkenlerinin değerleri arttırılır ya da eksiltilir. Birden çok işlem için aralarına virgül koymak gerekir.
<pre>
    degisken1++, degisken2 -= 4
</pre>
    </dd>
</dl>
<br />
Aşağıdaki tam bir örnektir:
<br />
<pre>
for( var degisken = 1; degisken <= 5; degisken++ ) {
  myArray[degisken] = 1;
}
</pre>
myArray[1]'den myArray[5]'e kadar hepsi 1 olur.
<br />
<h3>'for - in' Döngüsü</h3>

Bu döngü bir nesnenin tüm özellikleri ya da bir dizinin tüm öğeleri için kullanılır. Döngü öğeler bitince son bulur. Her yeni öğe ya da özellik eklendiğinde açılıp sergilenen öğelere eklenmiş olurlar. Tüm iç öğeler de (javascript tarafından üretilenler dahil) açılıp sergilenir. Ama Javascript yorumlayıcısı kendi eklediklerini gizler. Burada özel durumlarla pek ilgilenmemek gerekir. Çünkü tarayıcılara bağımlı olarak gizlenen ya da açılan iç öğeler farklılık gösterir.

<br />
<br />
Burada da kullandığınız değişken adlarını tanımlamanız gerekir. "for in" döngüsü yazım kuralı şöyledir:
<pre>
for( var degisken in Nesne_yada_Dizi ) {
</pre>
<br />
Sergilenen her Nesne_yada_Dizi özelliği için döngü bir kez tamamlanır. Bir sonraki özellik desikene atanır. Bu özelliğe erişmek için dizi yazım kuralı kullanılabilir. Aşağıdaki örnek sergilenen özellikleri yazar:
<br />
<pre>
for( var degisken in document ) {
  document.write( degisken + ' = ' + document[degisken] + '<br>' );
}
</pre>
<br />
Eğer bu döngüyü bir dizide kullanırsanız sayılanmış ve adlanmış öğeleri listeler hatta iç kullanımla ilgili length (uzunluk) özelliğini de gösterir. Kullanımda sorun olmaması için özenle kullanılmalıdır.
<br />
<h3>'while' Döngüsü</h3>

<br />
'while' döngüsü 'for' döngüsüne benzer. Fark ilk değerlerle, döngü sonu işlemlerindedir. Döngü koşulu doğru olduğu sürece devam eder.
<pre>
var deger = 1;

while( deger <= 5 ) {
  myArray[deger] = 1;
  deger++;
}
</pre>
myArray[1]'dan myArray[5]'e kadar hepsi 1 olur.

<br />
<br />
Burada arttırma ya da eksiltme işlemini kullanıp kodlamayı 'myArray[degisken++] = 1;' yazarak kısaltabilirsiniz. Burada önce "degisken" dizinin öğesini işaretler sonra değeri arttırılır.

<br />
<br />
Bunun tersi de çalışır: 'myArray[++degisken] = 1;'.
Burada önce degiskenin değeri arttırılır sonra yeni değer dizinin hücresini işaretler. 

<br />
<br />
Bu özellikler döngü dışında da çalışır. Ama daha çok döngü içinde kullanılır.
<h3>'do - while' Döngüsü</h3>

<br />
<br />
Bu da aynı "while" döngüsü gibidir ama çok önemli bir farkla. Koşul döngünün sonunda hesaplanır. Bu nedenle döngü en az bir kez çalışır.
<pre>
var degisken = 1;

do {
  myArray[degisken] = 1;
  degisken++;
} while( degisken <= 5 );
</pre>
myArray[1]'den myArray[5]'e kadar 1 olur.
<h3>'switch' Deyimi</h3>

<br />
"switch" yinelenmiş "if" deyimi gibidir. Burada degiskenin değeri listelenenlerden hangisine uyarsa o deyimler çalıştırılır.
<br />
<pre>
switch(degisken) {
  case 1:
    //Eğer degisken 1 ise çalıştırılır
  case 'sample':
    //Eğer degisken 'sample' (ya da 1, nedeni aşağıda anlatıldı) ise
    //burası çalıştırılır
  case false:
    //Eğer degisken false (ya da 1 ya da 'sample', aşağıdaki paragrafa bakın)
    //burası çalıştırılır
  default:
    //Eğer değişken hiç birine uymuyorsa (ya da 1 ise
    //ya da 'sample' ya da false, alttaki paragrafa bakın)
    //burası çalıştırılır
}
</pre>
<br />
Eğer "case" uyumluysa onun altındaki kod çalıştırılır "break" deyimi kullanılmazsa altıındaki kodlar da çalıştırılır. Buna karşın çözüm "break" deyimi kullanmaktır.
<br />
<pre>
switch(değişken) {
  case 1:
    //Eğer degisken 1 ise çalıştırılır
    break;
  case 'sample':
    //Eğer degisken 'sample' ise çalıştırılır
    break;
  case false:
    //Eğer degisken false ise çalıştırılır
    break;
  default:
    //Eğer degisken hiçbirine uymazsa burası çalıştırılır
    //break; burada gereksizdir, izleyen deyim ya da koşul yok...
}
</pre>
<h3>'with' Deyimi</h3>

<br />
Aşağıdaki örneğe bakın:
<pre>
x = Math.round( Math.LN2 + Math.E + Math.pow( y, 4 ) );
</pre>
'with' deyimi kullanılarak aşağıdaki gibi kodlanabilir:
<pre>
with( Math ) {
  x = round( LN2 + E + pow( y, 4 ) );
}
</pre>
<br />
'with' deyimi fazladan değişken adlarını o anki kapsam içine alır. Eğer daha önce pow adlı bir değişkeniniz varsa bu değişken with deyimi içinde geçerli değildir. Çünkü aynı adlı Math yçntemiyle değişmiştir. Bir kez with deyimi kapandı mı, eski değişken yeniden kullanılabilir.

<h3>Çabuk 'if' deyimi</h3>

<br />
Buna koşullu atama işlemi de denir. Değişik değerleri koşullara göre bir değişkene atama işlemidir.
<br />
<pre>
var myVariable = document.getElementById ? 1 : 0;
</pre>
Bununla aşağıdaki özdeştir:
<pre>
if( document.getElementById ) {
  var myVariable = 1;
} else {
  var myVariable = 0;
}
</pre>
<h3>try - catch - finally deyimi</h3>

    <li> Netscape 4, Internet Explorer 4 ve WebTV bu yapıyı desteklemez ve hata verir.</li>

<br />
'try - catch - finally' denetim yapısı hataları yakalarken hata mesajı oluşturmadan ya da kodlamayı kesmeden sessizce denetimi tamamlanamaktır. Aslında işlemleri akan kodlamayı da kesmeye gerek olmaz.
<pre>
window.onerror = referenceToFunction;
</pre>
'try - catch - finally' denetim yapısının yazım kuralları şöyledir:
<pre>
try {
  //buarda hata veren bir deyim olsun 
} catch( myError ) {
  //Eğer hata olursa, bu kodlama çalışır
  //nesnedeki iki özellik (varsayılan olarak) deyime geçer
  alert( myError.name + ': ' + myError.message );
} finally {
  //seçenekli - yakaladığınız hatayı yeniden oluştursanız bile
  //bu kodlama denetim yapısı bitmeden çalışır
}
</pre>
Eğer 'try' bölümünde bir hata oluşursa, ihatayla ilgili bilgiyi de geçirerek hemen 'catch' bölümüne geçilir. Aynı hata için değişik tarayıcılar değişik hatalar oluştururlar. Teoride, DOM tarayıcıları belirli sınıflara ayrılmış hata mesajları oluştururlar. Ama sonuçlar DOM uyumluluk düzeylerine bağımlıdır. 'try' ve 'catch' bölümü bittikten sonra 'finally' bölümü çalışır.

<br />
<br />
Eğer bu deyimleri iç içe kullanırsanız, hatayı içteki 'catch' bölümünden dıştaki 'catch' bölümüne taşıyabilirsiniz. Eğer varsa içteki 'finally' bölümü dıştaki 'catch' çalışmadan bitirilir ama içtekini izleyen kodlama çalıştırılmaz. Bu işlem 'throw' (fırlat) yöntemiyle gerçekleşir.
<pre>
try{
  //...Buradaya bir takım kod yazılır
  try {
    var a = nonexist.b; //Bu hata verir
  } catch(myError) {
    //Hatayı yakalar ve mesaj verir
    alert( myError.message );
    //hatayı dışarıdaki try-catch ikilisine fırlat
    throw( myError );
  }
  //...burada başka bir kod var
} catch( myErrorObject ) {
  //Buraya fırlatılan hata düşer. Bu nedenle hata nesnesi 
  // aynıdır. O halde mesaj da aynı olur.
  alert( myErrorObject.message );
}
</pre>
Kendi hatalarınızı da herhangi noktadan fırlatabilirsiniz. Hatayı gerekli özelliklerle üretir ve throw deyimine uygun parametre yaparsanız işlem tamamlanır:
<br />

<pre>
try{
  var myEr = new Object();
  myEr.name = 'My error';
  myEr.message = 'Benim istemediğim bir şey yaptınız';
  throw( myEr );
} catch( detectedError ) {
  alert( detectedError.name + '\n' + detectedError.message );
}
</pre>

<h3>Bunda hatalı olan ne?</h3>

Eski tarayıcılar bunu desteklemez ama şükür artık kimse onları kullanıyor. Örneğin NN 4 bunu desteklemiyor. Halbuki desteklese ne çok hata oluşurdu.
<br />
<br />

Maalesef bu yapıyı desteklemeyen bir tarayıcıda kullanılırsa tarayıcı tüm kodlamayı keser. Denetleme yapısını kullanmasa bile kodlama kesilir.
<br />
<br />

Hiçbir zaman tarayıcının destekleyip desteklemediği araştırılan document.getElementId gibi olmayacaktır. O zaman nerede kullanılacaktır?
<br />
<br />

W3C DOM kodlamasında kullanılabilir. Örneğin değişen DOM hatalarında kullanılabilir. Bunlar bilinen hatalardır ama size bir şeyleri nasıl yapmamanız gerektiğini söyler. Başka tarayıcılar DOM desteklemezse bu hatayla ilgilenmeleri zaten gerekmez. O halde Javascript 1.2 kullanmak gerekir (daha yükseği değil). Bunun anlamı eski tarayıcılar hala hata verebilir ama onların hata kaldırma koşulları korunmalıdır.
<br />
<br />

Bazen sizin fırlattığınız hatalar için de kullanılır. Ama hatayı bazı koşullara uygun hazırlamak gerekir.
<br />
<br />

"Frameset" bir "frame" için tarayıcı güvenlik hatası yaparsa kullanılabilir. Güvenlik hatası frame içeriği bir başka siteye aitse gerçekleşir).
<br />
<br />

Eğer değişik tarayıcılar aynı deyimi değişik biçimlerde yorumladığında kullanılmalıdır. Örneğin selectBox.add yöntemi (bu yöntem DOm bölümüne bu karışıklıktan doyalı eklenmedi):
<pre>
try {
  selectBox.add(optionObject,otherOptionObject);
} catch ( e ) {
  selectBox.add(optionObject,index);
}
</pre>
<h3>Koşul olmadan koşullular</h3>

Çabuk 'if' deyiminde olduğu gibi bazen bir özellik hiçbir değerle koşul oluşturmadan kullanılır: 'if(document.getElementId)' gibi...
<br />
<br />

Bu geçerli bir kullanımdır. Hatta Javascript kodlamanın en kullanışlı işlemidir. En önemli kurallardan biridir. Nesne ve beceri balirleme amaçlı kullanım olduğu için tarayıcılar arası kodlamada çok anlamlıdır:
<pre>
document.getElementById != "" &&
document.getElementById != 0 &&
document.getElementById != false &&
document.getElementById != undefined &&
document.getElementById != null
</pre>
Tüm bu koşulların yerine: 'if( !document.getElementById )' yazılmış olunur.
<br />
<br />

Bu kullanım doğrudur eğer:
<pre>
document.getElementById == "" ||
document.getElementById == 0 ||
document.getElementById == false ||
document.getElementById == undefined ||
document.getElementById == null
</pre>
doğruysa...
<br />
<br />

Bunu kullanarak bir tek beceri vardır. Yanlışsa, başkasına bak, yoksa aranan bulunmuştur...
<br />
<br />

Bunu koşul gerektiren her yerde kullanabilirsiniz. 'do while' döngüsünde, 'while' koşulunda olduğu gibi...
<h3>Özellikleri 'in' ile denetleme</h3>

    <li> Olmayan bir özelliği 'in' işlemiyle denetlemek istediğinizde WebTV çalışmaz.</li>
    <li> Windows altındaki Netscape 4, Internet Explorer 5.0 ve Mac'ta Internet Explorer 'in' işlemini burada gösterildiği gibi kullanmaz.
<br />
<br />

'for - in' döngüsündeki 'in' işleminin başka bir amacı vardır. Bir nesnenin adlandırılmış özelliklerini denetlemek için de kullanılır. Bir çok yerde koşul olmadan koşullular kullanmak en iyisidir. Bazen denetlenen özelliğin sonucu "doğru" bile olmayabilir. Belki değeri 0, boş dizi ya da null olabilir.
<br />
<br />

Eğer özelliğin türünü biliyorsanız özdeşlik kullanarak denetleme olanağı doğabilir. Örnek:
<pre>
if( typeof( document.body.innerHTML ) == 'string' ) {
</pre>
Bir özelliği denemek için de 'in' işlemi kullanılabilir. Bu var oluşu denemenize de olanak verir (değişkenin o anda neyi var ya da neyi o anda bulunuduruyor). 'for - in' döngüsünde 'in' işlemi özelliğin adlarını döndürür. Burada da adın bir yazı dizisi olması beklenir. Kullanımı biraz sınırlar, çünkü yalnız adları tarayabilir ve bir özelliğin özel bir tür ya da değer taşıyıp taşımadığını belirleyemez.
<br />

<pre>
if( 'innerHTML' in document.body ) {
</pre>

Bu işlem IE'de koşulsuz koşullulardan 20 kez daha yavaştır. Pek çok tarayıcıda her iki seçenek de hemen hemen aynı sonucu verir. Burada en sık kullananı seçnek yararlıdır. Ama çok özel bir amaç varsa 'in' işlemini kullanabilirsiniz.
<br />
<h3>Koşul içinda atamai yapma</h3>

Javascript bir koşulu denerken bir değikene atama yapılmasını da sağlar. Bir koşul içinde yer alabildiğinden 
'if', 'for', 'while' ve 'do - while' deyimleriyle kullanılabilir.
<br />

<pre>
if( x = document.getElementById('mydiv') ) {...}

do {
  alert( node.tagName );
} while( node = node.parentNode );
</pre>

IE bu işlemi bir diziyle yaparsanız, dizinin sonunu geçerse hata mesajı verir
<h3>Continue ve break deyimleriyle Etiketler (label)</h3>
<h3>Labels</h3>

Etiketler 'while', 'do - while', 'for', 'for - in' ve 'switch' denetim deyimlerininde kullanılır. Yazım kuralı:
<pre>
Etiket_adı:
Denetim Yapısı
</pre>
Etiketler Javascript için hemen hiç kullanılmaz.
<h3>break deyimi</h3>

switch, for, for-in, while ya da  do - while idenetim yapılarında break kullanmak programın deyim sonuna zıplamasını sağlar. Örnek:
<pre>
for( var x = 1; x < 5; x++ ) {
  var y = 1;
  while( y < 7 ) {
    y++;
    if( y == 5 ) { break; }
    document.write(y);
  }
}
</pre>
y değeri 6 ise kodlama while döngüsünün sonuna sıçrar. Ama bunu kullanınca:
<pre>
myForLoop:
for( var x = 1; x < 5; x++ ) {
  var y = 1;
  while( y < 7 ) {
    y++;
    if( y == 5 ) { break myForLoop; }
    document.write(y);
  }
}
</pre>
y değeri 5 ise kodlama for döngüsünün sonuna sıçrar.
<h3>continue deyimi</h3>

Writing continue inside a
'for', 'for - in', 'while' ya da 'do - while' denetim yapılarında, continue kullanmak programın deneme koşuluna sıçramasını ve 'her_zaman_bunu_yap' bölümündekileri yapmasını sağlar. Örnek:
<pre>
for( var x = 1; x < 5; x++ ) {
  var y = 1;
  while( y < 7 ) {
    y++;
    if( y == 5 ) { continue; }
    document.write(y);
  }
}
</pre>
Bu kodlama y değeri 5 olunca deneme koşuluna sıçrar, 5 hiç yazılmaz ama 6 ve 7 yazılır. Yerine bu kullanılırsa:

<pre>
myForLoop:
for( var x = 1; x < 5; x++ ) {
  var y = 1;
  while( y < 7 ) {
    y++;
    if( y == 5 ) { continue myForLoop; }
    document.write(y);
  }
}
</pre>

Burada kodlama x değerini döngünün bir parçası olarak arttırır ve koşulu yeniden dener.
</div>
<br />
</body>
</html>
