<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PHP - Veri tabanı güvenliği </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<META content=0 http-equiv=expires>
<link rel="stylesheet" type="text/css" href="main.css" media="screen" />
<script language="JavaScript" src="../js/browser.js"> </script>
<script type="text/javascript">
function myvoid()
{
}
</script>
</head>

<body onLoad="ayarla();">
<div id="taban">
    <table cellpadding="0" cellspacing="0" width="100%">
    <tr><td valign="top">
       <div id="soltaraf">
           <a href="../index.html"><img src="../img/aybim.png" border="0"></a><br /><br />
           <div class="menublock">
               <font color="#8e9ccb"><h3>Tanımlar</h3></font>
               <a href="javascript:myvoid();" class="nav">Başlarken</a>
               <a href="phptxt11.html" class="sub">ilk Anlatım</a>
               <a href="javascript:myvoid();" class="nav">Kurulumlar</a>
               <a href="phptxt21.html" class="sub">Genel Kurulum</a><br />
               <a href="phptxt22.html" class="sub">UNIX Kurulumu</a><br />
               <a href="phptxt23.html" class="sub">OSX Kurulumu</a><br />
               <a href="phptxt24.html" class="sub">Wins Kurulumu</a>
               <a href="javascript:myvoid();" class="nav">Dil Kuralları</a>
               <a href="phptxt31.html" class="sub">Temel yazım</a><br />
               <a href="phptxt32.html" class="sub">Tipler</a><br />
               <a href="phptxt33.html" class="sub">Değişkenler</a><br />
               <a href="phptxt34.html" class="sub">Değişmezler</a><br />
               <a href="phptxt35.html" class="sub">Deyimler</a><br />
               <a href="phptxt36.html" class="sub">İşlemler</a><br />
               <a href="phptxt37.html" class="sub">Kontrol Yapıları</a><br />
               <a href="phptxt38.html" class="sub">İşlevler</a><br />
               <a href="phptxt39.html" class="sub">Sınıflar Nesneler</a><br />
               <a href="phptxt391.html" class="sub">Ad uzayı</a><br />
               <a href="phptxt392.html" class="sub">İstisnalar</a>
               <a href="javascript:myvoid();" class="nav">Güvenlik</a>
               <a href="phptxt41.html" class="sub">Giriş</a><br />
               <a href="phptxt42.html" class="sub">Genel bilgi</a><br />
               <a href="phptxt43.html" class="sub">CGI iklisi</a><br />
               <a href="phptxt44.html" class="sub">Apache modülü</a><br />
               <a href="phptxt45.html" class="sub">Dosyadüzeni</a><br />
               <a href="phptxt46.html" class="sub">Veritabanı</a><br />
               <a href="phptxt47.html" class="sub">Hatalar</a><br />
               <a href="phptxt48.html" class="sub">Diğerleri</a><br />
               <a href="javascript:myvoid();" class="nav">Özellikler</a>
               <a href="phptxt51.html" class="sub">HTTP Şifresi</a><br />
               <a href="phptxt52.html" class="sub">Çerezler</a><br />
               <a href="phptxt53.html" class="sub">Oturumlar</a><br />
               <a href="phptxt54.html" class="sub">XForm</a><br />
               <a href="phptxt55.html" class="sub">DosyaYükleme</a><br />
               <a href="phptxt56.html" class="sub">UzakDosyalar</a><br />
               <a href="phptxt57.html" class="sub">Bağlantılar</a><br />
               <a href="phptxt58.html" class="sub">VTBağlantısı</a>
               <font color="#8e9ccb"><h3>Gelişmiş</h3></font>
               <a href="phptxt7.html" class="nav">Php Kökü</a>
               <a href="phptxt8.html" class="nav">Ekler</a>
           </div>
       </div>
    </td><td valign="top">
       <center><h2>PHP Hyperlink Preprocessor</h2></center>
       <div id="ortataraf">
<!-- cascading style sheets ardaşık stil sayfaları -->
         <span><img src="img/notebook1.gif"></span>
         <div id="canvas">
<div id="sag"><span class="yazi">2 Şubat 2008</span></div>
<div id="bdy" class="yazi">
<h2>Veri tabanı güvenliği</h2>

Bugünlerde web sitelerinin değişken ve dinamik içerik sağlamasına katkılarından dolayı veri tabanları çok kullanılan önemli parçalardır. Hassas ve gizli bilgiler de veri tabanında saklanabildiğinden, veri tabanlarınızı çok iyi korumalısınız.
<br /><br />
Okumak ya da yazmak için veri tabanına bağlanmak, sorgu hazırlamak, yanıtı almak ve bağlantıyı kapatmak gerekir. Bugünlerde veri tabanına bağlantı SQL (yapısal sorgulama dili) ile yapılır. 
<br /><br />
Anlaşılacağı gibi PHP veri tabanınızı kendi başına koruyamaz. Aşağıdaki bölüm, PHP kodlamasından veri tabanına erişimin temel ilkelerini anlatmayı amaçlar.
<br /><br />
Bu temel kuralı aklınızda tutun: Savunmanız derinliğine olmalıdır. Veri tabanınızı korumak için ne kadar çok yerde işlem yaparsanız, saldırganın verilerinize erişip yaygınlaştırması o kadar zor olur. Veri tabanı şemasının iyi tasarımı ve uygulaması en büyük korkunuz olur.
<h3>Veri Tabanı Tasarımı</h3>

İlk adım olarak, üçüncü partilerinki kullanmayacaksanız, önce veri tabanını yaratın. Veri tabanı yaratılınca, yaratma adımını kullanan kişiye atanır. Bu kişi veri tabanının işlem yapan sahibi olur. Genelde yalnız sahibi (ya da süper kullanıcı) veri tabanındaki nesneler üzerine birşeyler yapar ve diğer kullanıcıların neler yapabileceği yetkisini de o verir.
<br /><br />
Uygulamalar veri tabanına onu yaratan ya da süper kullanıcı olarak bağlanmamalıdır. Çünkü bu kullanıcılar istendiğinde her tür sorgulamayı yapabilirler. Örneğin şemayı değiştirmek (tabloyu düşürmek gibi) ya da içerin tümünü silmek gibi...
<br /><br />
Uygulamanızın her parçası için değişik veri tabanı kullanıcıları yaratabilir ve herbirine çok sınırlı veri tabanı erişimleri sunabilirsiniz. En önemli yetkileri alan diğer yetkilerin erişebildiği ortamlara erişmeyecek biçimde olmalıdır. Bilinçsiz bir kullanıcının yetkiyi ele geçirmesi söz konusu olduğunda yalnız o kullanıcının yetkileri ölçüsünde veri tabanınız zarar görecektir.
<br /><br />
Tüm işinizin web uygulamasıyla yapılmasını önerilmez (yani kodlamalarınız). Yerine veri tabanı şemasında görüntüler yaratarak, tetikleme yaparak ya da kurallar kullanarak çalışılmalıdır. Eğer sistem yetki verirse yeni "port" kullanımıyla veri tabanı açılmalı ve her veri tabanı için ayrı kullanım ortamı oluşturma mantığını yeniden uyarlamalısınız. Bunların üstüne ve üzerine tetikleme, saydam ve otomatik veri alanı ele alma amacıyla kullanılmalıdır. Bunlar çoğu zaman düzeltme amaclı temizleme işlemlerinde kullanılır.
<br />
<hr>

<h3>Veri tabanına bağlantı</h3>

"SSL" üzerinden bağlantı kurmak istediğinizde istemci/sunucu işlemlerinizi kriptolamış olursunuz. Veri tabanı sunucusu ve islemciler arasında "ssh" kullanarak da bağlantı kurabilirsiniz. Bunlardan birini kullanmışsanız veri tabanınıza erişimde kullandığınız bilgilere saldırganın erişmesi çok zordur...
<br />
<hr>

<h3>Kriptolanmış yardımcı bellek modeli (Encrypted Storage Model)</h3>

SSL/SSH istemciyle sunucu arasındaki veri akışını korur. SSL/SSH veri tabanında bulunan verileri korumaz. Çünkü SSL hat üzerinde çalışan bir protokol olarak tanımlanmıştır.
<br /><br />
Saldırgan bir kez veri tabanına doğrudan erişmeyi sağlarsa (web sunucuyu atlayarak), saklanan hassas veri açılabilir ya da kullanılmaz olur. Ama bilgiyi veri tabanın içinde korumaya alırsanız böyle olmaz. Veriyi kriptolama bu açıdan iyi bir yöntemdir. Ama pek az veri tabanı bu tür kriptolamayı destekler.
<br /><br />
Bu sorunu geçmenin en önemli yolu, kendi kriptolama modülünüzü yazmanızdır. Sonra bunu PHP kodlamanız içinde kullanmanızdır. PHP birçok uzantıyla (Mcrypt ve Mhash gibi) size bu konuda destek de olur. Kodlama verinizi veri tabanına eklemeden kriptolar ve okurken de kriptoyu kaldırır. 
<br /><br />
Gerçekten gizlenen verilerde, ham görünümü istenmiyorsa (yani görüntülenmeyecekse), "hash" yönyemi dikkate alınabilir. En çok bilinen "hash" yöntemi şifrenin "md5 hash" ile veri tabanında saklanmasıdır. Şifre için crypt() ve md5() kullanılır. Şifre açık olarak saklanmaz.
<br /><br />
Karıştırılmış şifre alanı örneği
<pre>
&lt;?php

// şifre karıştırılmasını saklama
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            pg_escape_string($username), md5($password));
$result = pg_query($connection, $query);

// eğer kullanıcı doğru şifreyi girmişse sorgualam
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            pg_escape_string($username), md5($password));
$result = pg_query($connection, $query);

if (pg_num_rows($result) > 0) {
    echo 'Hoşgeldin, $username!';
} else {
    echo '$username için şifre hatası.';
}

?&gt;
</pre>
<hr>

<h3>SQL Enjeksiyonu (Injection)</h3>

Birçok geliştirici SQL sorgularının nasıl bozulacağını bilmez bile. SWL komutunun güvenilir olduğunu düşünelim. Bunun anlamı erişim kontrolunu geçmesi (şifreleme denetiminden geçmesi) demektir. Bazen SQL sorguları işletim sistemi komutlarını da kullanabilir.
<br /><br />
Doğrudan SQL komut enjeksiyonu, saldırganın sorguyu değiştirip gizli veriyi açma, üzerine yazma ya da tehlikeli sistem düzeyi komutları çalıştırma girişimidir. Bunun oluşma biçimi uygulamanın kullanıcı girişini SQL sorgusundaki değişmez parametrelerle birleştirmesi sırasında olur. Aşağıdaki örnek istenmese de gerçek öykülere dayanır.
<br /><br />
Giriş kontrolu eksikliği ve veri tabanına süper kullanıcı ya da sahibi olarak bağlanmak (yeni kullanıcı yaratmasını sağlamak), saldırgana sizin veri tabanında süper kullanıcı yaratmanızı sağlar
<br /><br />
sonuç kümesini sayfalara bölmek... ve süper kullanıcı yapmak (PosrgreSQL).
<pre>
&lt;?php

$offset = $argv[0]; // dikkat edin giriş kontrolu yok
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
$result = pg_query($conn, $query);

?&gt;
</pre>
Normal kullanıcılar "next" ve "prev" bağlarını tıklayarak $offset için kodlanmış URL adreslerini kullanırlar. Kodlama gelen $offset değerinin ondalık sayı olduğunu varsayar. Ama biri araya girip forma "urlencode()" eklenmesi yaparsa:
<pre>
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--
</pre>
Eğer yaparsa, kodlama kendisine süper kullanıcı erişimi sağlar. Burada 0; asıl sorguya geçerli başlama noktası sunar ve onu sonlandırır.
<br /><br />
    Not: Bu SQL taramasına, sorgunun kalanını unutması (dikkate almaması) için yazılan genel bir kuraldır. SQL içinde açıklamanın başlangıcını tanımlar.
<br /><br />
Şifreyi almak için en uygun yol, sorgulama sonucu sayfalarını tuzağa düşürmektir. Saldırganın bilmesi gereken tek şey, SQL satırında gönderilen değişkelerden hangisinin doğru ele alınmadığını bulmaktır. Bu engeller (filitreler) aşağıdaki form içinde kişiselleşirilecek SELECT deyimindeki WHERE, ORDER BY, LIMIT ve OFFSET koşullarıyla atanır. Eğer veri tabanınız UNION yapısını destekliyorsa, saldırgan şifreleri listelemek için tüm sorguyu asıl sorgunun peşine ekler. Bu durumda kriptolanmış şifre satırları kullanılması şiddetle önerilir.
<br /><br />
Konuları listelemek... ve bazı şifreleri de (herhangi veri tabanı sunucusunda)
<pre>
&lt;?php

$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);

?&gt;
</pre>
Sorgunun değişmez bölümü başka bir SELECT ile birleştirilir. O da tüm şifreleri açar.
<pre>
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
</pre>
Eğer bu sorgu (' ve -- ile oynayarak) $query içindeki bir değişkene atanırsa, sorgunun canavarı uyandırılmış olur.
<br /><br />
SQL güncellemeler de saldırmaya çok yatkın işlemlerdir. Bu sorgular da kesilerek ve sonuna yeni sorgular eklenerek yepyeni sorgulara dönüşür. Ama saldırgan daha çok SET koşulu üzerinde parmaklarını oynatır. Bu örnekte bazı şema bilgisi de sorguyu başarıyla değiştirmek için ayarlanmalıdır. Kullanılan form değişkenlerini inceleyerek, ya da yalnız kaba kuvvetle ele geçirilir. Şifre ve kullanıcı adı için çok fazla adlandırma kavramı da yoktur.
<br /><br />
Şifreyi silmekten... daha çok yetki almaya kadar (her veri tabanı için)
<pre>
&lt;?php
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
?&gt;
</pre>
Fakat kötü niyetli kullanıcı $uid içine ' or uid like '%admin%'; -- yazarak gönderir. Bu biçimiyle sorgulama "admin" şifresini değiştirir ya da $pwd değerini 'hehehe', admin='yes', trusted=100 " (en arkadaki boşluğuyla) daha çok yetki almayı sağlayabilir. Sonra sorgu yer değiştirebilir.
<pre>
&lt;?php

// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE
...;";

?&gt;
</pre>

Bazı veri tabanı sunucularında işletim sistemi komutlarının nasıl erişildiğini gösteren örnekler
<br /><br />
Veri tabanı işletim sistemine saldırı (MSSQL Sunucuda)
<pre>
&lt;?php

$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);

?&gt;
</pre>
Eğer saldırgan $prod değerini a%' exec master..xp_cmdshell 'net user test testpass /ADD' -- olarak gönderirse $query şöyle olur:
<pre>
&lt;?php

$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);

?&gt;
</pre>
MSSQL Sunucu, toplu iş adımlarındaki SQL satırlarını peşindeki yerel veri tabanına yeni kullanıcı ekleme komutuyla çalıştırır. Eğer bu uygulama sistem yöneticisi (sa) olarak çalışıyorsa ve MSSQLSERVER servisleri yeterli yetkilerle çalışıyorsa, saldırganın bu bilgisayara erişim için artık bir kullanıcı hesabı vardır.
<br /><br />
    Not: Buradaki örneklerden bazıları özel veri tabanı sunucularına bağlanmıştır. Bu başka ürünlerde benzeri saldırıların başarılı olamayacağı anlamına gelmez. Sizin veri tabanınız da bir başka işlem için aynı biçimde savunmasız olabilir.

<h3>Kaçınılacak teknikler</h3>

Yukarudaki örneklerden saldırganın veri tabanı şeması hakkında bir bilgiye sahip olması gerektiği savını ileri sürebilirsiniz. Savınız doğrudur. Ama ne zaman ve nasıl olduğunu bilmezsiniz. Bildiğinizde de veri tabanınız açılmıştır. Açık kaynak kodlama kullanıyorsanız ya da halka açık veri tabanı paketi kullanıyorsanız onun içerik yönetim sistemi ya da bir forumu vardır. Davetsiz misafirler sizin kodunuzun bir kopyasını alırlar. Eğer zayıf bir tasarımı varsa aynı zaman bu bir güvenlik riski oluşturur.
<br /><br />
Bu saldırılar güvenlik dikkate alınmadan yapılan kodlamaları temel alırlar. Herhangi bir girişe güvenmeyin. Özellikle istemci tarafından gelen koda... Bir seçenek kutusundan gelse, gizli giriş analanı olsa ya da çerek olsa bile güvenmeyin. İlk örnekte görüldüğü gibi bu tür saçma bir sorgu yıkıntıya neden olabilir.
<ul>
    <li> Veri tabanına süper kullanıcı olarak ya da veri tabanı sahibi olarak bağlanmayın. Her zaman sınırlı yetkileri olan  kişiselleştirilmiş kullanıcılarla işlem yapın.
    <li> Sunulan giiriş bilgisinin istenen veri tipinde olduğunu denetleyin. PHP içinde giriş denetimi için pek çok denetim işlevi vardır. Değişken işlevlerindeki ve karakter tipi işlevlerdeki en basitlerinden (is_numeric(), ctype_digit() gibi), Perl uyumlu kurallı deyimlere kadarını destekler işlevler vardır.
    <li>

Eğer uygulama sayısal giriş bekliyorsa, veriyi is_numeric() ile denetlemeye çalışın. Ya da türünü settype() kullanarak değiştirin, ya da sprintf() kullanarak onun sayısal değerini alın.
<br /><br />
Listelemek için daha güvenli bir sorgulama yapma yolu
      <pre>
&lt;?php

settype($offset, 'integer');
$query = "SELECT id, name FROM products
          ORDER BY name LIMIT 20 OFFSET $offset;";

// aşağıda %d kullanımına dikkat edin. Burada %s kullanmak çok anlamsızdır
$query = sprintf("SELECT id, name FROM products
                  ORDER BY name LIMIT 20 OFFSET %d;", $offset);

?&gt;
      </pre>
Sayısal olmayan kullanıcının sunduğu değerleri veri tabanına özel yazı dizisi atlatma işlevi (escape function) kullanarak alın (örneğin mysql_escape_string(), sql_escape_string() vb.). Eğer veri tabanı atlatma işlevi yoksa, örneklerde görüldüğü gibi sorgulamanın değişmez bölümlerinde tırnak işaretleri eklemek yeterli değildir. Bu yöntem sorgulamayı çok kolay kırılır yapar...
    <li> Veri tabanına özel hiçbir şeyi yazdırmayın. Özellikle şemayı. Hata yadırma ve Hatayı ele alma ve log yazdırma işlevlerine de bakın.
    <li> Saklanan yordamları kullanabilirsiniz ve veriyi özetleyen önceden tanımlanmış imleçler (cursor) kullanabilirsiniz. Bu durumda doğrudan tablolara ya da görüntülere (views) doğrudan erişmeniz gerekmez. Ama bu çözümünde başka etki ortaya çıkar.
</ul>
Bunların dışında, ister sizin kodlamanızdan ya da veri tabanının kendisinden sorguların log kayıtlarını kullanma olanağı vardır. Doğal olarak log'lar zararlı saldırıları önlemez. Tuzağa düşürülen uygulamanda olayın nasıl olduğunu geriye dönük tarama amcıyla izleyebilirsiniz. Bu nedenle log kendi başına bir anlam kazandırmaz. Ama içeriğindeki bilgiyle sorunu bulmaya yarar. Hiç yoktan da iyidir.
<br />
</div>
         </div>
         <span><img src="img/notebook1.gif"><br /></span>
       </div>
    </td><td valign="top">
       <div id="sagtaraf">

       </div>
    </td></tr>
    </table>
</div>
</body>
</html>
